{
  "hash": "57f0d975f4311732b80b103566e23202",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Cell-free DNA Whole-Genome Bisulfite Sequencing Analysis of ALS vs Control\"\nsubtitle: \"Comprehensive cfDNA Fragmentomics and Methylation Analysis for Disease Classification\"\nauthor:\n  - name: \"Qi Yan\"\n    affiliation: \"cfDNA WGBS Study | GSE164600\"\ndate: today\ndate-format: \"MMMM D, YYYY\"\nabstract: |\n  This report presents some representative analyses of cell-free DNA (cfDNA) from whole-genome bisulfite \n  sequencing (WGBS) data comparing amyotrophic lateral sclerosis (ALS) patients with healthy controls.\n  The analyses include quality control metrics, insert size distributions, 5' end motif profiling,\n  differential methylation analysis, and classification. All analyses are performed\n  on chromosome 21 as a representative subset for computational efficiency.\nkeywords: [cfDNA, WGBS, ALS, methylation, fragmentomics, classification, DMRseq, stackHMM, Random Forest]\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-tools: true\nexecute:\n  echo: true\n  warning: false\n  message: false\nbibliography: references.bib\n---\n\n\n\n# Introduction\n\nCell-free DNA (cfDNA) analysis has emerged as a powerful non-invasive approach for disease detection and monitoring. In this study, we analyze cfDNA from whole-genome bisulfite sequencing (WGBS) data to distinguish amyotrophic lateral sclerosis (ALS) patients from healthy controls.\n\nThe analysis integrates multiple cfDNA features:\n\n1. **Quality Control**: Mapping statistics, bisulfite conversion efficiency, and coverage metrics\n2. **Insert Size Analysis**: Insert size distributions and nucleosome positioning patterns\n3. **End Motif Profiling**: 5' end 4-mer motif frequencies reflecting nuclease preferences\n4. **DNA Methylation**: Differentially methylated regions (DMRs) using dmrseq\n5. **Machine Learning Classification**: Random Forest with nested cross-validation\n\n## Study Design\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Sample distribution by group</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Group </th>\n   <th style=\"text-align:center;\"> N Samples </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:center;\"> 10 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:center;\"> 12 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n### Sample Demographics\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Age Distribution Plot\"}\n# Figure 0: Age distribution by group ----\np_age <- ggplot(metadata, aes(x = Group, y = Age, fill = Group)) +\n  geom_boxplot(alpha = 0.8, outlier.shape = 16, outlier.size = 2) +\n  geom_jitter(width = 0.12, size = 1.8, alpha = 0.5) +\n  scale_fill_manual(values = COLORS) +\n  labs(title = \"Age distribution by group\", x = \"Group\", y = \"Age\") +\n  theme_classic(base_size = 14) +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5, size = rel(1.2),\n                              margin = ggplot2::margin(b = 8)),\n    plot.subtitle = element_text(hjust = 0.5, margin = ggplot2::margin(b = 6)),\n    axis.title = element_text(face = \"bold\"),\n    axis.text = element_text(color = \"black\"),\n    legend.title = element_text(face = \"bold\"),\n    panel.grid.major = element_line(color = \"gray90\", linewidth = 0.3, linetype = \"dotted\"),\n    plot.margin = ggplot2::margin(12, 12, 12, 12)\n  )\nggsave(file.path(FIG_DIR, \"fig0_age_distribution_by_group.png\"), p_age, width = 6, height = 5, dpi = 450)\n```\n:::\n\n\n![Age distribution by group showing comparable age ranges between ALS and Control cohorts.](results/figures/fig0_age_distribution_by_group.png){#fig-age-dist width=\"60%\"}\n\n---\n\n# Quality Control {#sec-qc}\n\n::: {.panel-tabset}\n\n## Methods\n\n### Sample Demographics\n\nSample age distributions were compared between ALS and Control groups to assess demographic balance. \nAge was visualized using boxplots with individual data points overlaid to show the full distribution.\n\n### Data Preprocessing and Quality Control\n\nQuality control metrics were extracted from aligned BAM files generated by Bismark [@krueger2011bismark]. \nThe following QC procedures were applied:\n\n**Alignment Statistics (flagstat)**\nRead-level statistics were computed by parsing SAM flags to determine:\n\n- Total reads and mapping rate\n- Properly paired reads (both mates mapped in correct orientation)\n- Duplicate reads (PCR/optical duplicates)\n- Secondary and supplementary alignments\n\n**Quality Filtering**\nReads were filtered using the following criteria:\n\n- Paired-end reads with both mates mapped (`isPaired = TRUE`, `isProperPair = TRUE`)\n- Mapping quality MAPQ ≥ 30\n- Non-duplicate reads (`isDuplicate = FALSE`)\n- Primary alignments only (`isSecondaryAlignment = FALSE`, `isSupplementaryAlignment = FALSE`)\n\n**Fragment Extraction**\nFragment coordinates were derived from paired-end alignments using a BEDPE-style approach:\n\n- Fragment start: minimum alignment start position\n- Fragment end: maximum alignment end position\n- Fragment length: end - start (retained if 0 < length ≤ 1000 bp)\n\n**GC Content**\nGC content was calculated per fragment as (G+C)/(A+C+G+T), excluding N bases, using the \nBSgenome.Hsapiens.UCSC.hg38 reference genome [@bsgenome].\n\n**Methylation Metrics**\nBismark XM tags were parsed to extract methylation calls:\n\n- CpG methylation rate: methylated CpG (Z) / (Z + z)\n- Bisulfite conversion efficiency: 1 - CHH methylation rate\n  - CHH methylation should be <1% for complete bisulfite conversion [@lister2009human]\n\n### Statistical Analysis\n\nGroup comparisons were performed using two-sided Student's t-test. Visualizations were generated.\n\n### Software\n\n- **R**: v4.5.1\n- **Rsamtools**: BAM file parsing [@rsamtools]\n- **BSgenome.Hsapiens.UCSC.hg38**: Reference genome sequences\n- **ggplot2**: Data visualization\n\n## Code\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"QC Functions\"}\n# ============================================================================\n# QC FUNCTIONS\n# ============================================================================\n\n## Flagstat function ----\nget_flagstat <- function(bam_path) {\n  \n  param_all <- ScanBamParam(what = \"flag\")\n  bf <- BamFile(bam_path, yieldSize = 5e6)\n  open(bf)\n  \n  total <- 0\n  mapped <- 0\n  paired <- 0\n  proper_pair <- 0\n  duplicates <- 0\n  secondary <- 0\n  supplementary <- 0\n  \n  repeat {\n    flags <- scanBam(bf, param = param_all)[[1]]$flag\n    if (length(flags) == 0) break\n    \n    total <- total + length(flags)\n    mapped <- mapped + sum(bitwAnd(flags, 4) == 0)        # bit 4 = unmapped\n    paired <- paired + sum(bitwAnd(flags, 1) > 0)         # bit 1 = paired\n    proper_pair <- proper_pair + sum(bitwAnd(flags, 2) > 0)  # bit 2 = proper pair\n    duplicates <- duplicates + sum(bitwAnd(flags, 1024) > 0) # bit 1024 = duplicate\n    secondary <- secondary + sum(bitwAnd(flags, 256) > 0)    # bit 256 = secondary\n    supplementary <- supplementary + sum(bitwAnd(flags, 2048) > 0) # bit 2048 = supplementary\n  }\n  close(bf)\n  \n  data.frame(\n    total_reads = total,\n    mapped = mapped,\n    unmapped = total - mapped,\n    paired = paired,\n    properly_paired = proper_pair,\n    duplicates = duplicates,\n    secondary = secondary,\n    supplementary = supplementary,\n    mapping_rate = mapped / total,\n    proper_pair_rate = proper_pair / paired,\n    duplicate_rate = duplicates / total\n  )\n}\n\n## Parse Bismark XM methylation tags ----\nparse_xm_tags <- function(xm_tags) {\n  all_chars <- paste(xm_tags, collapse = \"\")\n  \n  data.frame(\n    Z = stringr::str_count(all_chars, \"Z\"),  # methylated CpG\n    z = stringr::str_count(all_chars, \"z\"),  # unmethylated CpG\n    X = stringr::str_count(all_chars, \"X\"),  # methylated CHG\n    x = stringr::str_count(all_chars, \"x\"),  # unmethylated CHG\n    H = stringr::str_count(all_chars, \"H\"),  # methylated CHH\n    h = stringr::str_count(all_chars, \"h\")   # unmethylated CHH\n  )\n}\n\n## Extract BAM metrics ----\nextract_bam_metrics <- function(bam_path, sample_id, genome, chunk_size = 1e6, frag_dir = FRAG_DIR) {\n  \n  message(sprintf(\"Processing: %s\", sample_id))\n  \n  if (!file.exists(bam_path)) {\n    warning(sprintf(\"BAM file not found: %s\", bam_path))\n    return(NULL)\n  }\n  \n  # Get flag statistics\n  flagstat <- get_flagstat(bam_path)\n  \n  # BAM parameters\n  param <- ScanBamParam(\n    flag = scanBamFlag(isPaired = TRUE, isProperPair = TRUE,\n                       isUnmappedQuery = FALSE, hasUnmappedMate = FALSE,\n                       isDuplicate = FALSE,\n                       isSecondaryAlignment = FALSE, isSupplementaryAlignment = FALSE,\n                       isNotPassingQualityControls = FALSE),\n    what = c(\"qname\", \"flag\", \"rname\", \"pos\", \"mapq\", \"cigar\", \"isize\", \"seq\", \"qwidth\"),\n    tag = c(\"XM\")\n  )\n  \n  bf <- BamFile(bam_path, yieldSize = chunk_size)\n  open(bf)\n  \n  frag_lengths <- integer()\n  meth_calls <- list()\n  total_reads <- 0\n  mapq_values <- integer()\n  gc_values <- numeric()\n  \n  # Fragment BED output\n  fragment_bed_path <- file.path(frag_dir, paste0(sample_id, \".fragments.bed.gz\"))\n  frag_con <- gzfile(fragment_bed_path, open = \"wt\")\n  on.exit(try(close(frag_con), silent = TRUE), add = TRUE)\n  \n  pending_aln <- tibble::tibble(\n    qname = character(), flag = integer(), rname = character(),\n    pos = integer(), cigar = character(), mapq = integer()\n  )\n  \n  repeat {\n    chunk_raw <- scanBam(bf, param = param)[[1]]\n    if (length(chunk_raw$qname) == 0) break\n    \n    mapq_values <- c(mapq_values, chunk_raw$mapq)\n    keep_idx <- which(chunk_raw$mapq >= 30)\n    chunk <- lapply(chunk_raw, function(x) {\n      if (length(x) == length(chunk_raw$mapq)) return(x[keep_idx])\n      if (is.list(x)) return(lapply(x, function(tag_vector) tag_vector[keep_idx]))\n      return(x)\n    })\n    \n    total_reads <- total_reads + length(chunk$qname)\n    \n    # Fragment pairing\n    if (length(chunk$qname) > 0) {\n      aln <- tibble::tibble(\n        qname = as.character(chunk$qname),\n        flag = as.integer(chunk$flag),\n        rname = as.character(chunk$rname),\n        pos = as.integer(chunk$pos),\n        cigar = as.character(chunk$cigar),\n        mapq = as.integer(chunk$mapq)\n      ) %>%\n        dplyr::filter(!is.na(qname), !is.na(rname), !is.na(pos), !is.na(cigar),\n                      is.finite(pos), pos > 0L)\n      \n      if (nrow(aln) > 0) {\n        aln <- aln %>%\n          dplyr::mutate(\n            start0 = pos - 1L,\n            end0_excl = start0 + as.integer(cigarillo::cigar_extent_along_ref(cigar)),\n            strand = dplyr::if_else(bitwAnd(flag, 16L) > 0L, \"-\", \"+\")\n          ) %>%\n          dplyr::filter(is.finite(start0), is.finite(end0_excl), end0_excl > start0)\n        \n        aln_all <- dplyr::bind_rows(pending_aln, aln)\n        tab <- table(aln_all$qname)\n        have_pair <- names(tab[tab >= 2L])\n        \n        if (length(have_pair) > 0) {\n          pair_rows <- aln_all %>%\n            dplyr::filter(qname %in% have_pair) %>%\n            dplyr::group_by(qname) %>%\n            dplyr::slice(1:2) %>%\n            dplyr::ungroup()\n          \n          pending_aln <- aln_all %>% dplyr::filter(!(qname %in% have_pair))\n          \n          pair_rows <- pair_rows[order(pair_rows$qname), , drop = FALSE]\n          mate_raw <- stats::ave(pair_rows$qname, pair_rows$qname, FUN = seq_along)\n          \n          idx1 <- which(mate_raw == 1L)\n          idx2 <- which(mate_raw == 2L)\n          \n          same_chr <- pair_rows$rname[idx1] == pair_rows$rname[idx2]\n          swap_per_pair <- ifelse(\n            same_chr,\n            pair_rows$start0[idx1] > pair_rows$start0[idx2],\n            pair_rows$rname[idx1] > pair_rows$rname[idx2]\n          )\n          \n          i1 <- ifelse(swap_per_pair, idx2, idx1)\n          i2 <- ifelse(swap_per_pair, idx1, idx2)\n          \n          pair_w <- tibble::tibble(\n            qname = pair_rows$qname[idx1],\n            rname_1 = pair_rows$rname[i1], start0_1 = pair_rows$start0[i1],\n            end0_excl_1 = pair_rows$end0_excl[i1], mapq_1 = pair_rows$mapq[i1],\n            strand_1 = pair_rows$strand[i1],\n            rname_2 = pair_rows$rname[i2], start0_2 = pair_rows$start0[i2],\n            end0_excl_2 = pair_rows$end0_excl[i2], mapq_2 = pair_rows$mapq[i2],\n            strand_2 = pair_rows$strand[i2]\n          ) %>%\n            dplyr::filter(!is.na(rname_1) & !is.na(rname_2))\n          \n          pair_w <- pair_w %>% dplyr::arrange(rname_1, start0_1)\n          \n          if (nrow(pair_w) > 0) {\n            score <- pmin(pair_w$mapq_1, pair_w$mapq_2)\n            same_chr <- pair_w$rname_1 == pair_w$rname_2\n            \n            if (any(same_chr)) {\n              frag_start0 <- pair_w$start0_1[same_chr]\n              frag_end0 <- pair_w$end0_excl_2[same_chr]\n              length_bp <- frag_end0 - frag_start0\n              \n              keep_len <- is.finite(length_bp) & length_bp > 0L & length_bp <= 1000L\n              if (any(keep_len)) {\n                gc <- rep(NA_real_, sum(keep_len))\n                gr_frag <- GenomicRanges::GRanges(\n                  seqnames = pair_w$rname_1[same_chr][keep_len],\n                  ranges = IRanges::IRanges(\n                    start = as.integer(frag_start0[keep_len] + 1L),\n                    end = as.integer(frag_end0[keep_len])\n                  ),\n                  strand = \"*\"\n                )\n                \n                gc <- tryCatch({\n                  seqs <- BSgenome::getSeq(genome, gr_frag)\n                  acgt <- Biostrings::letterFrequency(seqs, letters = c(\"A\", \"C\", \"G\", \"T\"), as.prob = FALSE)\n                  denom <- rowSums(acgt)\n                  num_gc <- acgt[, \"C\"] + acgt[, \"G\"]\n                  ifelse(denom > 0, num_gc / denom, NA_real_)\n                }, error = function(e) rep(NA_real_, length(gr_frag)))\n                \n                frag_lines <- paste(\n                  pair_w$rname_1[same_chr][keep_len],\n                  as.integer(frag_start0[keep_len]),\n                  as.integer(frag_end0[keep_len]),\n                  pair_w$qname[same_chr][keep_len],\n                  as.integer(score[same_chr][keep_len]),\n                  pair_w$strand_1[same_chr][keep_len],\n                  as.integer(length_bp[keep_len]),\n                  formatC(gc, format = \"f\", digits = 4),\n                  sep = \"\\t\"\n                )\n                writeLines(frag_lines, con = frag_con, useBytes = TRUE)\n                frag_lengths <- c(frag_lengths, as.integer(length_bp[keep_len]))\n                gc_values <- c(gc_values, gc)\n              }\n            }\n          }\n        } else {\n          pending_aln <- aln_all\n        }\n      }\n    }\n    \n    # Methylation calls\n    if (!is.null(chunk$tag$XM)) {\n      xm_tags <- chunk$tag$XM[!is.na(chunk$tag$XM)]\n      if (length(xm_tags) > 0) {\n        meth_calls[[length(meth_calls) + 1]] <- parse_xm_tags(xm_tags)\n      }\n    }\n    \n    rm(chunk)\n    gc(verbose = FALSE)\n  }\n  \n  close(bf)\n  \n  meth_summary <- if (length(meth_calls) > 0) {\n    do.call(rbind, meth_calls) %>% summarise(across(everything(), sum))\n  } else {\n    data.frame(Z = 0, z = 0, X = 0, x = 0, H = 0, h = 0)\n  }\n  \n  list(\n    sample_id = sample_id,\n    fragment_bed = fragment_bed_path,\n    flagstat = flagstat,\n    filtered_reads = total_reads,\n    fragment_lengths = frag_lengths,\n    gc_content = gc_values,\n    mapq = mapq_values,\n    methylation = meth_summary\n  )\n}\n\n## Calculate summary statistics ----\ncalculate_summary_stats <- function(metrics) {\n  if (is.null(metrics)) return(data.frame(sample_id = NA))\n  \n  fl <- metrics$fragment_lengths\n  gc <- metrics$gc_content\n  meth <- metrics$methylation\n  fs <- metrics$flagstat\n  \n  cpg_total <- meth$Z + meth$z\n  cpg_meth_rate <- if (cpg_total > 0) meth$Z / cpg_total else NA\n  \n  chh_total <- meth$H + meth$h\n  chh_meth_rate <- if (chh_total > 0) meth$H / chh_total else NA\n  bisulfite_conv <- if (!is.na(chh_meth_rate)) 1 - chh_meth_rate else NA\n  \n  data.frame(\n    sample_id = metrics$sample_id,\n    total_reads = fs$total_reads,\n    mapped_reads = fs$mapped,\n    unmapped_reads = fs$unmapped,\n    properly_paired = fs$properly_paired,\n    duplicates = fs$duplicates,\n    mapping_rate = fs$mapping_rate,\n    proper_pair_rate = fs$proper_pair_rate,\n    duplicate_rate = fs$duplicate_rate,\n    filtered_reads = metrics$filtered_reads,\n    filter_pass_rate = metrics$filtered_reads / fs$total_reads,\n    gc_content = mean(gc, na.rm = TRUE),\n    n_fragments = length(fl),\n    mean_frag_length = mean(fl),\n    median_frag_length = median(fl),\n    sd_frag_length = sd(fl),\n    frag_mode = as.numeric(names(sort(table(fl), decreasing = TRUE))[1]),\n    short_frag_ratio = sum(fl < 150) / length(fl),\n    mono_nuc_ratio = sum(fl >= 150 & fl <= 220) / length(fl),\n    di_nuc_ratio = sum(fl >= 300 & fl <= 400) / length(fl),\n    mean_mapq = mean(metrics$mapq),\n    cpg_methylation = cpg_meth_rate,\n    chh_methylation = chh_meth_rate,\n    bisulfite_conversion = bisulfite_conv\n  )\n}\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"QC Analysis Pipeline\"}\n# ============================================================================\n# PROCESS ALL SAMPLES\n# ============================================================================\n\nall_metrics <- lapply(seq_len(nrow(metadata)), function(i) {\n  row <- metadata[i, ]\n  bam_path <- file.path(RAW_DIR, row$Bam_file)\n  \n  metrics <- extract_bam_metrics(\n    bam_path = bam_path,\n    sample_id = row$sample_id,\n    genome = genome,\n    frag_dir = FRAG_DIR\n  )\n  \n  return(metrics)\n})\n\n# Filter out failed samples\nall_metrics <- all_metrics[!sapply(all_metrics, is.null)]\n\nif (length(all_metrics) == 0) {\n  stop(\"No BAM files found. Please check data/raw/ directory.\")\n}\n\nsaveRDS(all_metrics, file.path(DATA_DIR, \"processed\", \"all_metrics.rds\"))\n\n# Summary statistics table\nsummary_stats <- purrr::map_dfr(all_metrics, calculate_summary_stats)\nsummary_stats <- summary_stats %>%\n  dplyr::left_join(metadata, by = \"sample_id\")\n\nreadr::write_csv(summary_stats, file.path(TABLE_DIR, \"qc_summary_stats.csv\"))\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"QC Visualization Code\"}\n# ============================================================================\n# QC VISUALIZATION\n# ============================================================================\n\nkey_metrics <- summary_stats %>%\n  dplyr::select(\n    sample_id, Group, total_reads, filtered_reads, median_frag_length,\n    mean_mapq, cpg_methylation, bisulfite_conversion, gc_content\n  ) %>%\n  dplyr::mutate(\n    total_reads_m = total_reads / 1e6,\n    filtered_reads_m = filtered_reads / 1e6,\n    bisulfite_conversion_pct = 100 * bisulfite_conversion,\n    cpg_methylation_pct = 100 * cpg_methylation\n  )\n\nkey_metrics_long_sample <- key_metrics %>%\n  dplyr::select(sample_id, Group, total_reads_m, filtered_reads_m, median_frag_length,\n                mean_mapq, cpg_methylation_pct, bisulfite_conversion_pct, gc_content) %>%\n  tidyr::pivot_longer(\n    cols = c(total_reads_m, filtered_reads_m, median_frag_length, mean_mapq,\n             cpg_methylation_pct, bisulfite_conversion_pct, gc_content),\n    names_to = \"metric\",\n    values_to = \"value\"\n  ) %>%\n  dplyr::mutate(\n    sample_id = factor(sample_id, levels = key_metrics %>%\n                         dplyr::arrange(Group, sample_id) %>%\n                         dplyr::pull(sample_id)),\n    metric = factor(\n      metric,\n      levels = c(\"total_reads_m\", \"filtered_reads_m\", \"mean_mapq\", \"median_frag_length\",\n                 \"gc_content\", \"cpg_methylation_pct\", \"bisulfite_conversion_pct\"),\n      labels = c(\"Total reads (M)\", \"Filtered reads (M)\", \"Mean MAPQ\",\n                 \"Median fragment length (bp)\", \"GC content (%)\",\n                 \"CpG methylation (%)\", \"Bisulfite conversion (%)\")\n    )\n  )\n\n# Per-sample bar plot\np_qc_sample <- ggplot(key_metrics_long_sample, aes(x = value, y = sample_id, fill = Group)) +\n  geom_col(width = 0.8, alpha = 0.95) +\n  facet_wrap(~metric, scales = \"free_x\", ncol = 3) +\n  scale_fill_manual(values = COLORS) +\n  labs(title = \"QCs by sample\", x = NULL, y = \"Sample\", fill = \"Group\") +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"top\", axis.text.y = element_text(size = 7))\n\n# Group comparison boxplot\np_qc_group <- ggplot(key_metrics_long_sample, aes(x = Group, y = value, fill = Group)) +\n  geom_boxplot(width = 0.55, outlier.shape = NA, alpha = 0.95) +\n  geom_jitter(width = 0.12, size = 1.8, alpha = 0.5) +\n  facet_wrap(~metric, scales = \"free_y\", ncol = 4) +\n  scale_fill_manual(values = COLORS) +\n  labs(title = \"QCs by group\", x = NULL, y = NULL) +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"none\") +\n  ggpubr::stat_compare_means(method = \"t.test\")\n\n# Combined figure\np_qc_combined <- p_qc_group / p_qc_sample +\n  patchwork::plot_annotation(tag_levels = \"A\") +\n  patchwork::plot_layout(heights = c(1, 1.4))\n\nggsave(file.path(FIG_DIR, \"fig1_qc_key_metrics.png\"),\n       p_qc_combined, width = 14, height = 18, dpi = 300)\n```\n:::\n\n\n## Results\n\n### QC Summary Statistics\n\nThe following quality control metrics were computed for all samples:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover table-condensed\" style=\"font-size: 11px; width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption style=\"font-size: initial !important;\">Quality control metrics by sample</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Sample </th>\n   <th style=\"text-align:left;\"> Group </th>\n   <th style=\"text-align:right;\"> Total Reads </th>\n   <th style=\"text-align:right;\"> Filtered Reads </th>\n   <th style=\"text-align:right;\"> Mapping Rate </th>\n   <th style=\"text-align:right;\"> Dup Rate </th>\n   <th style=\"text-align:right;\"> CpG Meth </th>\n   <th style=\"text-align:right;\"> BS Conv </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404367 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 128,966 </td>\n   <td style=\"text-align:right;\"> 111,610 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.7% </td>\n   <td style=\"text-align:right;\"> 99.5% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404368 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 129,002 </td>\n   <td style=\"text-align:right;\"> 112,358 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 83.2% </td>\n   <td style=\"text-align:right;\"> 99.5% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404369 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 128,158 </td>\n   <td style=\"text-align:right;\"> 110,314 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.9% </td>\n   <td style=\"text-align:right;\"> 99.6% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404370 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 125,118 </td>\n   <td style=\"text-align:right;\"> 108,808 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 81.5% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404371 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 126,020 </td>\n   <td style=\"text-align:right;\"> 110,432 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 83.8% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404372 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 127,650 </td>\n   <td style=\"text-align:right;\"> 111,156 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.8% </td>\n   <td style=\"text-align:right;\"> 99.5% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404373 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 128,022 </td>\n   <td style=\"text-align:right;\"> 111,700 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.9% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404374 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 124,984 </td>\n   <td style=\"text-align:right;\"> 109,154 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.0% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404375 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 128,512 </td>\n   <td style=\"text-align:right;\"> 111,202 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 83.9% </td>\n   <td style=\"text-align:right;\"> 99.6% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404376 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 127,878 </td>\n   <td style=\"text-align:right;\"> 111,140 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 81.4% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404377 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 126,344 </td>\n   <td style=\"text-align:right;\"> 109,590 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 80.8% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404378 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 128,540 </td>\n   <td style=\"text-align:right;\"> 111,958 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 81.0% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404379 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 125,496 </td>\n   <td style=\"text-align:right;\"> 108,714 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 81.3% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404380 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 126,848 </td>\n   <td style=\"text-align:right;\"> 110,044 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.9% </td>\n   <td style=\"text-align:right;\"> 97.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404381 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 128,312 </td>\n   <td style=\"text-align:right;\"> 111,678 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 81.9% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404382 </td>\n   <td style=\"text-align:left;\"> ALS </td>\n   <td style=\"text-align:right;\"> 127,718 </td>\n   <td style=\"text-align:right;\"> 111,378 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 81.5% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404383 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 127,270 </td>\n   <td style=\"text-align:right;\"> 111,738 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.6% </td>\n   <td style=\"text-align:right;\"> 98.8% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404384 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 125,438 </td>\n   <td style=\"text-align:right;\"> 109,654 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.6% </td>\n   <td style=\"text-align:right;\"> 99.6% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404385 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 127,184 </td>\n   <td style=\"text-align:right;\"> 111,094 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 80.9% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404386 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 127,730 </td>\n   <td style=\"text-align:right;\"> 111,698 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 81.0% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404387 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 125,304 </td>\n   <td style=\"text-align:right;\"> 108,872 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.4% </td>\n   <td style=\"text-align:right;\"> 99.8% </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SRR13404388 </td>\n   <td style=\"text-align:left;\"> Ctrl </td>\n   <td style=\"text-align:right;\"> 126,162 </td>\n   <td style=\"text-align:right;\"> 109,478 </td>\n   <td style=\"text-align:right;\"> 100.0% </td>\n   <td style=\"text-align:right;\"> 0.0% </td>\n   <td style=\"text-align:right;\"> 82.7% </td>\n   <td style=\"text-align:right;\"> 99.7% </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n### QC Metrics Visualization\n\n![Quality control metrics across samples and groups. (A) Comparison of key QC metrics between ALS and Control groups with t-test p-values. (B) Per-sample breakdown of QC metrics.](results/figures/fig1_qc_key_metrics.png){#fig-qc width=\"100%\"}\n\n**Key Observations:**\n\n- **Mapping rate**: High mapping rates (>95%) across all samples indicate good library quality\n- **Bisulfite conversion**: >99% conversion efficiency confirms complete bisulfite treatment\n- **CpG methylation**: Global CpG methylation levels are consistent between groups\n- **Fragment length**: Median fragment lengths cluster around the nucleosome-protected size (~167 bp); median fragment lengths differ between ALS vs. controls.\n\n:::\n\n---\n\n# Fragment Analysis {#sec-frag}\n\n::: {.panel-tabset}\n\n## Methods\n\n### Insert Size Distribution Analysis\n\nFragment length (insert size) distributions were analyzed to characterize nucleosome positioning \npatterns in cfDNA [@snyder2016cfdna; @cristiano2019fragmentomics].\n\n**Fragment Size Metrics**\n\n- Fragment lengths were extracted from paired-end alignments (30-500 bp range)\n- Key metrics computed per sample:\n  - Median and mode fragment length\n  - Short fragment ratio: fragments 100-150 bp / fragments 151-220 bp\n- The characteristic \"sawtooth\" pattern reflects nucleosome protection with ~10 bp periodicity \n  corresponding to DNA helical repeat [@snyder2016cfdna]\n\n**Nucleosome Positioning**\n\n- Mono-nucleosome peak: ~167 bp (147 bp core + ~20 bp linker)\n- Di-nucleosome peak: ~334 bp\n\n### Genome-wide Fragmentation Ratio\n\nFollowing the approach of Cristiano et al. [@cristiano2019fragmentomics], genome-wide fragmentation \npatterns were analyzed using short/long fragment ratios:\n\n**Bin Definition**\n\n- Genome tiled into 2 Mb bins (chr21 for computational efficiency)\n- Short fragments: 90-150 bp\n- Long fragments: 151-220 bp\n\n**GC Bias Correction**\n\nTo account for GC-dependent sequencing biases, LOESS regression was applied:\n\n1. Log-transformed fragment counts regressed against bin GC content\n2. Correction factor: observed / predicted × median(observed)\n3. Bins with extreme GC (<10% or >85%) or high N-fraction (>45%) excluded from model fitting\n\n### TSS Enrichment Analysis\n\nTranscription start site (TSS) enrichment profiles reveal nucleosome-free regions at active promoters:\n\n**Profile Generation**\n\n1. Fragment 5' start coordinates extracted (strand-aware)\n2. Positions counted relative to TSS (±2000 bp window)\n3. Signal normalized to edge mean (baseline = 1)\n4. Running average (k=40 bp) applied for smoothing\n\n**Annotation**\n- Gene-level TSS from TxDb.Hsapiens.UCSC.hg38.knownGene\n- ChIPseeker for genomic feature annotation [@yu2015chipseeker]\n\n### Statistical Analysis\n\n- Group comparisons: Student's t-test\n\n### Software\n\n- **GenomicRanges**: Genomic interval operations [@lawrence2013genomicranges]\n- **TxDb.Hsapiens.UCSC.hg38.knownGene**: Gene annotations\n- **ChIPseeker**: Feature annotation [@yu2015chipseeker]\n- **Gviz**: Chromosome-style visualizations (optional) [@hahne2016gviz]\n\n## Code\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Fragment Analysis Helper Functions\"}\n# ============================================================================\n# FRAGMENTATION ANALYSIS HELPERS\n# ============================================================================\n\nFRAG_COLS <- c(\"chrom\", \"start0\", \"end0\", \"name\", \"mapq\", \"strand\", \"length_bp\", \"gc\")\nFRAG_COL_CLASSES <- c(\n  chrom = \"character\", start0 = \"integer\", end0 = \"integer\",\n  name = \"character\", mapq = \"integer\", strand = \"character\",\n  length_bp = \"integer\", gc = \"numeric\"\n)\n\n# Chunked reader for gzipped fragment BEDs\nread_fragments_chunked <- function(path, chunk_size = 200000L, FUN) {\n  chunk_size <- as.integer(chunk_size)\n  con <- gzfile(path, open = \"rt\")\n  on.exit(try(close(con), silent = TRUE), add = TRUE)\n  \n  repeat {\n    x <- utils::read.delim(\n      file = con, header = FALSE, sep = \"\\t\", nrows = chunk_size,\n      col.names = FRAG_COLS, colClasses = FRAG_COL_CLASSES,\n      stringsAsFactors = FALSE, quote = \"\", comment.char = \"\", fill = TRUE\n    )\n    if (nrow(x) == 0) break\n    FUN(x)\n  }\n  invisible(TRUE)\n}\n\n# Moving average for smoothing\nmoving_average <- function(x, k = 21L) {\n  k <- as.integer(k)\n  if (k < 3L) return(x)\n  if (k %% 2L == 0L) k <- k + 1L\n  w <- rep(1 / k, k)\n  as.numeric(stats::filter(x, w, sides = 2, method = \"convolution\"))\n}\n\n# Convert BED chunk to fragment midpoint GRanges\nchunk_to_midpoint_gr <- function(df) {\n  start1 <- df$start0 + 1L\n  end1 <- df$end0\n  mid <- as.integer(floor((start1 + end1) / 2))\n  GenomicRanges::GRanges(\n    seqnames = df$chrom,\n    ranges = IRanges::IRanges(start = mid, width = 1L),\n    strand = \"*\",\n    length_bp = df$length_bp\n  )\n}\n\n# 5' fragment start coordinates (strand-aware)\nchunk_to_5p_start_gr <- function(df) {\n  start1 <- df$start0 + 1L\n  end1 <- df$end0\n  pos1 <- ifelse(df$strand == \"-\", end1, start1)\n  GenomicRanges::GRanges(\n    seqnames = df$chrom,\n    ranges = IRanges::IRanges(start = as.integer(pos1), width = 1L),\n    strand = \"*\"\n  )\n}\n\n# LOESS GC-bias correction\ncorrect_gc_bias <- function(counts, gc_values, fit_mask = NULL, pseudocount = 1, span = 0.75) {\n  counts <- as.numeric(counts)\n  gc_values <- as.numeric(gc_values)\n  pseudocount <- as.numeric(pseudocount)\n  \n  if (is.null(fit_mask)) {\n    fit_mask <- is.finite(gc_values) & is.finite(counts)\n  } else {\n    fit_mask <- as.logical(fit_mask) & is.finite(gc_values) & is.finite(counts)\n  }\n  fit_mask_in <- fit_mask\n  \n  y <- log(counts + pseudocount)\n  fit_mask <- fit_mask & is.finite(y)\n  \n  if (sum(fit_mask) < 20L) return(counts)\n  \n  fit <- stats::loess(\n    y[fit_mask] ~ gc_values[fit_mask],\n    span = span, degree = 1, family = \"symmetric\",\n    control = stats::loess.control(surface = \"direct\")\n  )\n  \n  pred <- stats::predict(fit, newdata = gc_values)\n  med <- stats::median(counts[fit_mask] + pseudocount, na.rm = TRUE)\n  corrected <- (counts + pseudocount) / exp(pred) * med\n  \n  corrected[!fit_mask_in] <- NA_real_\n  corrected[!is.finite(pred)] <- NA_real_\n  corrected\n}\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Insert Size Analysis Code\"}\n# ============================================================================\n# INSERT SIZE ANALYSIS\n# ============================================================================\n\n# Load pre-computed metrics\nall_metrics <- readRDS(file.path(DATA_DIR, \"processed\", \"all_metrics.rds\"))\n\nfrag_df <- purrr::map_dfr(all_metrics, function(m) {\n  data.frame(\n    sample_id = m$sample_id,\n    fragment_length = as.integer(m$fragment_lengths)\n  )\n}) %>%\n  dplyr::left_join(metadata, by = \"sample_id\")\n\ncalc_mode <- function(x) {\n  x <- x[is.finite(x)]\n  if (length(x) == 0) return(NA_integer_)\n  x <- as.integer(x)\n  tabulate(x, nbins = max(x)) |> which.max()\n}\n\ninsert_metrics <- frag_df %>%\n  dplyr::group_by(sample_id, Group) %>%\n  dplyr::summarise(\n    n_fragments = dplyr::n(),\n    median_bp = stats::median(fragment_length),\n    mode_bp = calc_mode(fragment_length),\n    short_n = sum(fragment_length >= 100 & fragment_length <= 150),\n    long_n = sum(fragment_length >= 151 & fragment_length <= 220),\n    short_long_ratio = dplyr::if_else(long_n > 0, short_n / long_n, NA_real_),\n    .groups = \"drop\"\n  )\n\n# Insert size metrics by group\nmetric_long <- insert_metrics %>%\n  dplyr::select(sample_id, Group, median_bp, mode_bp, short_long_ratio) %>%\n  tidyr::pivot_longer(\n    cols = c(median_bp, mode_bp, short_long_ratio),\n    names_to = \"metric\", values_to = \"value\"\n  ) %>%\n  dplyr::mutate(\n    metric = factor(metric,\n      levels = c(\"median_bp\", \"mode_bp\", \"short_long_ratio\"),\n      labels = c(\"Median (bp)\", \"Mode (bp)\", \"Short/Long ratio\"))\n  )\n\nis_metrics <- ggplot(metric_long, aes(x = Group, y = value, fill = Group)) +\n  geom_boxplot(width = 0.55, outlier.shape = NA, alpha = 0.9) +\n  geom_jitter(aes(color = Group), width = 0.12, size = 1.8, alpha = 0.7) +\n  scale_fill_manual(values = COLORS) +\n  scale_color_manual(values = COLORS) +\n  facet_wrap(~metric, scales = \"free_y\", ncol = 3) +\n  ggpubr::stat_compare_means(method = \"t.test\") +\n  labs(title = \"Insert size metrics\", x = NULL, y = NULL) +\n  theme_pub() +\n  theme(legend.position = \"none\")\n\n# Sawtooth plot (binwidth = 1)\nfrag_df_saw <- frag_df %>%\n  dplyr::filter(fragment_length >= 80 & fragment_length <= 450)\n\ncounts_saw <- frag_df_saw %>%\n  dplyr::count(sample_id, Group, fragment_length, name = \"n\")\n\nann_df <- counts_saw %>%\n  dplyr::group_by(sample_id, Group) %>%\n  dplyr::summarise(ymax = max(n), .groups = \"drop\") %>%\n  dplyr::left_join(insert_metrics, by = c(\"sample_id\", \"Group\")) %>%\n  dplyr::mutate(label = sprintf(\"Median: %.0f bp\", median_bp), x = 245, y = 0.92 * ymax)\n\nis_saw <- ggplot(counts_saw, aes(x = fragment_length, y = n)) +\n  geom_line(linewidth = 0.35, color = \"gray20\") +\n  geom_vline(xintercept = 167, linetype = \"dashed\", color = \"#2E2E2E\", linewidth = 0.4) +\n  geom_vline(xintercept = 334, linetype = \"dashed\", color = \"#2E2E2E\", linewidth = 0.4) +\n  geom_text(data = ann_df, aes(x = x, y = y, label = label),\n            inherit.aes = FALSE, hjust = 0, size = 2.6, color = \"gray10\") +\n  facet_wrap(~sample_id, scales = \"free_y\", ncol = 4) +\n  labs(\n    title = \"Sawtooth insert-size pattern (binwidth = 1)\",\n    subtitle = \"Dashed lines: mono-nucleosome (~167 bp) and di-nucleosome (~334 bp)\",\n    x = \"Fragment length (bp)\", y = \"Count\"\n  ) +\n  theme_pub(base_size = 10) +\n  theme(strip.text = element_text(size = 8, face = \"bold\"), axis.text = element_text(size = 8))\n\n# Group-level median distributions\nlen_min <- 30L; len_max <- 500L\nlen_grid <- len_min:len_max\n\nfrag_df_30_500 <- frag_df %>%\n  dplyr::filter(!is.na(fragment_length), fragment_length >= len_min, fragment_length <= len_max)\n\nsample_groups <- frag_df_30_500 %>% dplyr::distinct(sample_id, Group)\ncounts_30_500 <- frag_df_30_500 %>% dplyr::count(sample_id, Group, fragment_length, name = \"n\")\n\ncounts_full <- tidyr::crossing(sample_groups, fragment_length = len_grid) %>%\n  dplyr::left_join(counts_30_500, by = c(\"sample_id\", \"Group\", \"fragment_length\")) %>%\n  dplyr::mutate(n = dplyr::coalesce(n, 0L)) %>%\n  dplyr::group_by(sample_id, Group) %>%\n  dplyr::mutate(prop = n / sum(n), cum_prop = cumsum(prop)) %>%\n  dplyr::ungroup()\n\ngroup_median_dist <- counts_full %>%\n  dplyr::group_by(Group, fragment_length) %>%\n  dplyr::summarise(\n    median_prop = stats::median(prop, na.rm = TRUE),\n    median_cum_prop = stats::median(cum_prop, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nis_prop <- ggplot(group_median_dist, aes(x = fragment_length, y = median_prop, color = Group)) +\n  geom_line(linewidth = 0.8) +\n  geom_vline(xintercept = 167, linetype = \"dashed\", color = \"#2E2E2E\", linewidth = 0.4) +\n  geom_vline(xintercept = 334, linetype = \"dashed\", color = \"#2E2E2E\", linewidth = 0.4) +\n  scale_color_manual(values = COLORS) +\n  scale_x_continuous(limits = c(len_min, len_max), breaks = seq(50, 500, by = 50)) +\n  labs(\n    title = \"Median fragment size distribution (by group)\",\n    subtitle = sprintf(\"Proportion at each length (%dbp–%dbp)\", len_min, len_max),\n    x = \"Fragment length (bp)\", y = \"Median proportion\", color = \"Group\"\n  ) +\n  theme_pub(base_size = 11) +\n  theme(legend.position = \"top\")\n\nis_cum <- ggplot(group_median_dist, aes(x = fragment_length, y = median_cum_prop, color = Group)) +\n  geom_line(linewidth = 0.8) +\n  geom_vline(xintercept = 167, linetype = \"dashed\", color = \"#2E2E2E\", linewidth = 0.4) +\n  geom_vline(xintercept = 334, linetype = \"dashed\", color = \"#2E2E2E\", linewidth = 0.4) +\n  scale_color_manual(values = COLORS) +\n  scale_x_continuous(limits = c(len_min, len_max), breaks = seq(50, 500, by = 50)) +\n  scale_y_continuous(limits = c(0, 1)) +\n  labs(\n    title = \"Median cumulative fragment distribution (by group)\",\n    subtitle = sprintf(\"Proportion of reads with length ≤ N (%dbp–%dbp)\", len_min, len_max),\n    x = \"Fragment length (bp)\", y = \"Median cumulative proportion\", color = \"Group\"\n  ) +\n  theme_pub(base_size = 11) +\n  theme(legend.position = \"top\")\n\nis_combined <- is_metrics / is_saw / (is_prop | is_cum) +\n  patchwork::plot_annotation(tag_levels = \"A\") +\n  patchwork::plot_layout(widths = c(1, 1), heights = c(1, 1, 1))\n\nggsave(file.path(FIG_DIR, \"fig2_insert_size.png\"), is_combined, width = 14, height = 18, dpi = 300)\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Fragmentation Ratio Track Code\"}\n# ============================================================================\n# GENOME-BINNED FRAGMENTATION RATIO TRACKS\n# ============================================================================\n\nbin_size <- 2e6\nchroms <- paste0(\"chr\", c(21))\nseqlens <- GenomeInfoDb::seqlengths(genome)[chroms]\nseqlens <- seqlens[!is.na(seqlens)]\n\nbins_gr <- GenomicRanges::tileGenome(\n  seqlengths = seqlens, tilewidth = bin_size, cut.last.tile.in.chrom = TRUE\n)\n\nbins_df <- tibble::tibble(\n  bin_id = seq_along(bins_gr),\n  chrom = as.character(GenomeInfoDb::seqnames(bins_gr)),\n  start = start(bins_gr), end = end(bins_gr),\n  mid = as.integer(floor((start + end) / 2))\n)\n\n# GC content per bin\nbin_seqs <- Biostrings::getSeq(genome, bins_gr)\nfreq <- Biostrings::letterFrequency(bin_seqs, letters = c(\"A\", \"C\", \"G\", \"T\", \"N\"), as.prob = FALSE)\nacgt <- rowSums(freq[, c(\"A\", \"C\", \"G\", \"T\"), drop = FALSE])\ngc <- (freq[, \"G\"] + freq[, \"C\"]) / pmax(acgt, 1)\nn_frac <- freq[, \"N\"] / Biostrings::width(bin_seqs)\n\nbins_df <- bins_df %>%\n  dplyr::mutate(gc = as.numeric(gc), n_frac = as.numeric(n_frac))\n\n# Filter bins for LOESS fitting\ngc_min <- 0.10; gc_max <- 0.85; n_frac_max <- 0.45\nbins_keep_for_gc <- is.finite(bins_df$gc) &\n  bins_df$gc >= gc_min & bins_df$gc <= gc_max &\n  is.finite(bins_df$n_frac) & bins_df$n_frac <= n_frac_max\n\n# Count fragments per bin per sample\nfragment_paths <- file.path(FRAG_DIR, paste0(metadata$sample_id, \".fragments.bed.gz\"))\nnames(fragment_paths) <- metadata$sample_id\n\nbin_counts_one_sample <- function(path, bins_gr, short_range = c(90L, 150L), long_range = c(151L, 220L)) {\n  short_counts <- integer(length(bins_gr))\n  long_counts <- integer(length(bins_gr))\n  \n  cb <- function(x) {\n    l <- x$length_bp\n    keep <- !is.na(l) & l >= 30L & l <= 500L\n    if (!any(keep)) return(invisible())\n    x <- x[keep, , drop = FALSE]\n    l <- x$length_bp\n    mid_gr <- chunk_to_midpoint_gr(x)\n    \n    # Short\n    idx_s <- which(l >= short_range[1] & l <= short_range[2])\n    if (length(idx_s) > 0) {\n      hits <- findOverlaps(mid_gr[idx_s], bins_gr, ignore.strand = TRUE)\n      if (length(hits) > 0) {\n        tab <- tabulate(S4Vectors::subjectHits(hits), nbins = length(bins_gr))\n        short_counts <<- short_counts + tab\n      }\n    }\n    \n    # Long\n    idx_l <- which(l >= long_range[1] & l <= long_range[2])\n    if (length(idx_l) > 0) {\n      hits <- findOverlaps(mid_gr[idx_l], bins_gr, ignore.strand = TRUE)\n      if (length(hits) > 0) {\n        tab <- tabulate(S4Vectors::subjectHits(hits), nbins = length(bins_gr))\n        long_counts <<- long_counts + tab\n      }\n    }\n    invisible()\n  }\n  \n  read_fragments_chunked(path = path, chunk_size = 200000L, FUN = cb)\n  \n  short_corrected <- correct_gc_bias(short_counts, bins_df$gc, fit_mask = bins_keep_for_gc)\n  long_corrected <- correct_gc_bias(long_counts, bins_df$gc, fit_mask = bins_keep_for_gc)\n  ratio_corrected <- short_corrected / (long_corrected + 1)\n  \n  tibble::tibble(\n    bin_id = seq_along(bins_gr),\n    short_raw = short_counts, long_raw = long_counts,\n    short_gc_corrected = short_corrected, long_gc_corrected = long_corrected,\n    short_long_ratio = ratio_corrected\n  )\n}\n\nbin_tracks <- purrr::imap_dfr(fragment_paths, function(path, sample_id) {\n  bc <- bin_counts_one_sample(path, bins_gr = bins_gr)\n  bc %>%\n    dplyr::mutate(\n      sample_id = sample_id,\n      Group = metadata$Group[match(sample_id, metadata$sample_id)]\n    )\n})\n\nbin_tracks_summary <- bin_tracks %>%\n  dplyr::group_by(Group, bin_id) %>%\n  dplyr::summarise(median_short_long_ratio = stats::median(short_long_ratio, na.rm = TRUE), .groups = \"drop\") %>%\n  dplyr::left_join(bins_df, by = \"bin_id\") %>%\n  dplyr::arrange(match(chrom, chroms), start) %>%\n  dplyr::group_by(Group) %>%\n  dplyr::mutate(\n    chrom = factor(chrom, levels = chroms),\n    genome_x = {\n      chroms_present <- chroms[chroms %in% names(seqlens)]\n      chr_lens <- as.numeric(seqlens[chroms_present])\n      chr_offsets <- cumsum(c(0, head(chr_lens, -1L)))\n      names(chr_offsets) <- chroms_present\n      chr_offsets[as.character(chrom)] + mid\n    }\n  ) %>%\n  dplyr::ungroup()\n\nchrom_boundaries <- tibble::tibble(\n  chrom = chroms[chroms %in% names(seqlens)],\n  chr_len = as.numeric(seqlens[chroms[chroms %in% names(seqlens)]])\n) %>%\n  dplyr::mutate(\n    offset = cumsum(dplyr::lag(chr_len, default = 0)),\n    boundary = offset + chr_len,\n    center = offset + chr_len / 2\n  )\n\np_tracks <- ggplot(bin_tracks_summary, aes(x = genome_x, y = median_short_long_ratio, color = Group)) +\n  geom_hline(yintercept = 1, color = \"gray70\", linewidth = 0.35) +\n  geom_line(linewidth = 0.65, alpha = 0.95) +\n  geom_vline(data = chrom_boundaries, aes(xintercept = boundary),\n             inherit.aes = FALSE, color = \"gray88\", linewidth = 0.3) +\n  scale_color_manual(values = COLORS) +\n  scale_x_continuous(\n    breaks = chrom_boundaries$center,\n    labels = as.character(chrom_boundaries$chrom),\n    expand = expansion(mult = c(0.01, 0.01))\n  ) +\n  labs(\n    title = \"Genome-wide fragmentation ratio track (group median)\",\n    subtitle = sprintf(\"GC-corrected (LOESS): median short/long ratio in 2 Mb bins (GC in [%.2f, %.2f], N ≤ %.2f)\",\n                       gc_min, gc_max, n_frac_max),\n    x = \"Chromosome\", y = \"Median short/long ratio\", color = \"Group\"\n  ) +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"top\", axis.text.x = element_text(angle = 0, vjust = 0.5))\n\nggsave(file.path(FIG_DIR, \"fig3_fragmentation_ratio_tracks.png\"), p_tracks, width = 16, height = 6, dpi = 300)\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"TSS Enrichment Analysis Code\"}\n# ============================================================================\n# TSS ENRICHMENT ANALYSIS\n# ============================================================================\n\ntxdb <- TxDb.Hsapiens.UCSC.hg38.knownGene\n\n# Fragment start annotation\nannotate_fragment_starts_one_sample <- function(fragment_bed_gz, sample_id, group, chunk_size = 200000L) {\n  counts <- c(Promoter = 0L, Exon = 0L, Intron = 0L, Distal_Intergenic = 0L,\n              Three_UTR = 0L, Five_UTR = 0L, Downstream = 0L)\n  total <- 0L\n  \n  read_fragments_chunked(\n    path = fragment_bed_gz, chunk_size = chunk_size,\n    FUN = function(x) {\n      gr <- chunk_to_5p_start_gr(x)\n      if (length(gr) == 0) return(invisible())\n      total <<- total + length(gr)\n      \n      gr <- ChIPseeker::annotatePeak(gr, TxDb = txdb, level = \"gene\", addFlankGeneInfo = TRUE)\n      gr_anno <- data.frame(gr@anno) %>%\n        dplyr::mutate(\n          annotation_simple = gsub(\" \\\\(.*\", \"\", annotation),\n          annotation_simple = dplyr::case_when(\n            annotation_simple == \"5' UTR\" ~ \"Five_UTR\",\n            annotation_simple == \"3' UTR\" ~ \"Three_UTR\",\n            annotation_simple == \"Distal Intergenic\" ~ \"Distal_Intergenic\",\n            TRUE ~ annotation_simple\n          )\n        )\n      \n      counts_table <- table(gr_anno$annotation_simple)\n      for (annot in names(counts_table)) {\n        counts[[annot]] <<- counts[[annot]] + counts_table[[annot]]\n      }\n      invisible()\n    }\n  )\n  \n  tibble::tibble(\n    sample_id = sample_id, Group = group, total_starts = total,\n    Promoter = counts[[\"Promoter\"]], Exon = counts[[\"Exon\"]], Intron = counts[[\"Intron\"]],\n    Three_UTR = counts[[\"Three_UTR\"]], Five_UTR = counts[[\"Five_UTR\"]],\n    Distal_Intergenic = counts[[\"Distal_Intergenic\"]], Downstream = counts[[\"Downstream\"]]\n  )\n}\n\nstart_annot <- purrr::imap_dfr(fragment_paths, function(path, sample_id) {\n  annotate_fragment_starts_one_sample(\n    fragment_bed_gz = path,\n    sample_id = sample_id,\n    group = metadata$Group[match(sample_id, metadata$sample_id)]\n  )\n})\n\nstart_annot_long <- start_annot %>%\n  tidyr::pivot_longer(cols = c(Promoter, Exon, Intron, Three_UTR, Five_UTR, Distal_Intergenic, Downstream),\n                      names_to = \"annotation\", values_to = \"n\") %>%\n  dplyr::group_by(sample_id) %>%\n  dplyr::mutate(pct = 100 * n / sum(n)) %>%\n  dplyr::ungroup() %>%\n  dplyr::mutate(annotation = factor(annotation,\n    levels = c(\"Promoter\", \"Exon\", \"Intron\", \"Three_UTR\", \"Five_UTR\", \"Distal_Intergenic\", \"Downstream\")))\n\np_start_annot <- ggplot(start_annot_long, aes(x = sample_id, y = pct, fill = annotation)) +\n  geom_col(width = 0.85) +\n  facet_grid(~Group, scales = \"free_x\", space = \"free_x\") +\n  scale_y_continuous(limits = c(0, 105), expand = expansion(mult = c(0, 0.02))) +\n  scale_fill_brewer(palette = \"Set2\") +\n  labs(title = \"Genomic distribution of fragment 5' start sites\",\n       x = NULL, y = \"Percent of fragment\", fill = \"Annotation\") +\n  theme_bw(base_size = 11) +\n  theme(panel.grid.minor = element_blank(),\n        axis.text.x = element_text(angle = 60, hjust = 1, vjust = 1),\n        legend.position = \"top\")\n\n# TSS enrichment profile\ngenes_chr21 <- suppressMessages(GenomicFeatures::genes(txdb))\ngenes_chr21 <- genes_chr21[as.character(GenomeInfoDb::seqnames(genes_chr21)) %in% chroms]\n\nprofile_tss_enrichment_starts <- function(fragment_bed_gz, tss_windows, tss_site, tss_strand,\n                                          flank = 2000L, chunk_size = 200000L, edge_width = 200L) {\n  flank <- as.integer(flank)\n  rel_grid <- (-flank):flank\n  prof <- numeric(length(rel_grid))\n  n_total <- 0L\n  \n  read_fragments_chunked(\n    path = fragment_bed_gz, chunk_size = chunk_size,\n    FUN = function(x) {\n      gr <- chunk_to_5p_start_gr(x)\n      if (length(gr) == 0) return(invisible())\n      n_total <<- n_total + length(gr)\n      \n      hits <- GenomicRanges::findOverlaps(gr, tss_windows, ignore.strand = TRUE)\n      if (length(hits) == 0) return(invisible())\n      \n      q <- S4Vectors::queryHits(hits)\n      s <- S4Vectors::subjectHits(hits)\n      pos <- start(gr[q])\n      rel <- pos - tss_site[s]\n      rel[tss_strand[s] == \"-\"] <- -rel[tss_strand[s] == \"-\"]\n      rel <- rel[rel >= -flank & rel <= flank]\n      if (length(rel) > 0) prof <<- prof + tabulate(rel + flank + 1L, nbins = length(rel_grid))\n      invisible()\n    }\n  )\n  \n  cpm <- (prof / max(n_total, 1L)) * 1e6\n  edge_width <- as.integer(edge_width)\n  edge_idx <- c(seq_len(edge_width), (length(cpm) - edge_width + 1L):length(cpm))\n  edge_mean <- mean(cpm[edge_idx], na.rm = TRUE)\n  enrich <- if (is.finite(edge_mean) && edge_mean > 0) cpm / edge_mean else rep(NA_real_, length(cpm))\n  \n  tibble::tibble(rel_bp = rel_grid, enrichment = enrich)\n}\n\ntss_points_pc <- unique(GenomicRanges::promoters(genes_chr21, upstream = 0L, downstream = 1L))\ntss_windows_pc <- unique(GenomicRanges::promoters(genes_chr21, upstream = 2000L, downstream = 2000L))\ntss_site_pc <- start(tss_points_pc)\ntss_strand_pc <- as.character(strand(tss_points_pc))\n\ntss_profiles <- purrr::imap_dfr(fragment_paths, function(path, sample_id) {\n  profile_tss_enrichment_starts(\n    fragment_bed_gz = path, tss_windows = tss_windows_pc,\n    tss_site = tss_site_pc, tss_strand = tss_strand_pc, flank = 2000L\n  ) %>%\n    dplyr::mutate(\n      sample_id = sample_id,\n      Group = metadata$Group[match(sample_id, metadata$sample_id)]\n    )\n})\n\ntss_summary <- tss_profiles %>%\n  dplyr::group_by(Group, rel_bp) %>%\n  dplyr::summarise(\n    mean_enrich = mean(enrichment, na.rm = TRUE),\n    se_enrich = stats::sd(enrichment, na.rm = TRUE) / sqrt(sum(is.finite(enrichment))),\n    .groups = \"drop\"\n  )\n\ntss_smooth_k <- 40L\ntss_summary_s <- tss_summary %>%\n  dplyr::group_by(Group) %>%\n  dplyr::arrange(rel_bp) %>%\n  dplyr::mutate(\n    mean_smooth = moving_average(mean_enrich, k = tss_smooth_k),\n    mean_smooth = dplyr::if_else(is.na(mean_smooth), mean_enrich, mean_smooth)\n  ) %>%\n  dplyr::ungroup()\n\np_tss_global <- ggplot(tss_summary_s, aes(x = rel_bp, color = Group)) +\n  geom_hline(yintercept = 1, color = \"gray60\", linewidth = 0.35) +\n  geom_vline(xintercept = 0, color = \"gray30\", linewidth = 0.35) +\n  geom_line(aes(y = mean_smooth), linewidth = 0.95, na.rm = TRUE) +\n  scale_color_manual(values = COLORS) +\n  labs(\n    title = \"TSS enrichment of fragment 5' start sites (chr21 protein-coding genes)\",\n    subtitle = sprintf(\"Normalized by mean signal at window edges (±2000 bp; baseline = 1). Display: %d-bp running mean.\", tss_smooth_k),\n    x = \"Distance to TSS (bp)\", y = \"Normalized fragment density\", color = \"Group\"\n  ) +\n  theme_bw(base_size = 12) +\n  theme(panel.grid.minor = element_blank(), legend.position = \"top\")\n\np_tss_combined <- p_start_annot / p_tss_global +\n  patchwork::plot_annotation(tag_levels = \"A\") +\n  patchwork::plot_layout(heights = c(1.4, 1))\n\nggsave(file.path(FIG_DIR, \"fig4_fragmentation_analysis.png\"), p_tss_combined, width = 8, height = 5.5, dpi = 300)\n```\n:::\n\n\n## Results\n\n### Insert Size Distribution\n\n![Insert size analysis. (A) Comparison of insert size metrics between ALS and Control groups. (B) Per-sample sawtooth pattern showing nucleosome periodicity (dashed lines at 167 bp and 334 bp). (C-D) Group-level fragment size distribution and cumulative distribution.](results/figures/fig2_insert_size.png){#fig-insert-size width=\"100%\"}\n\n**Key Observations:**\n\n- The characteristic **sawtooth pattern** reflects the ~10 bp DNA helical repeat within nucleosome-protected regions\n- **Mono-nucleosome peak** (~167 bp) is prominent across all samples\n- **Short/long fragment ratio** shows potential differences between ALS and Control groups\n\n### Genome-wide Fragmentation Ratio\n\n![Genome-wide fragmentation ratio track (chr21). GC-corrected short/long ratio in 2 Mb bins showing regional variation in fragmentation patterns.](results/figures/fig3_fragmentation_ratio_tracks.png){#fig-frag-ratio width=\"100%\"}\n\n### Fragment Start Site Distribution\n\n![Fragment analysis. (A) Genomic distribution of fragment 5' start sites across annotated regions. (B) TSS enrichment profile showing nucleosome depletion at transcription start sites.](results/figures/fig4_fragmentation_analysis.png){#fig-frag-analysis width=\"100%\"}\n\n**Key Observations:**\n\n- **Intronic regions** harbor the majority of fragment starts, consistent with genome composition\n- **TSS enrichment** shows the expected depletion pattern at nucleosome-free promoter regions\n- Differences in fragmentation patterns may reflect tissue-of-origin changes in ALS: nucleosome occupancy at TSS and smoother pattern for control; phased nucleosomes for ALS. Indicating that muscle-specific fragments are detected in ALS.\n\n:::\n\n---\n\n# End Motif Analysis {#sec-motif}\n\n::: {.panel-tabset}\n\n## Methods\n\n### 5' End Motif Profiling\n\nCell-free DNA fragment ends exhibit characteristic sequence preferences reflecting the enzymatic \nprocesses involved in cfDNA generation [@jiang2020cfdna; @liu2024starprotocols]. The 4-mer \n(256 motif) end motif profile provides a comprehensive signature of nuclease cleavage preferences.\n\n**Motif Extraction**\n\nFor each fragment, two 4-mer motifs were extracted from the 5' ends:\n\n1. **Left end**: Genomic positions [start, start+4) on the + strand\n2. **Right end**: Genomic positions [end-4, end) on the - strand (reverse complement)\n\nSequences were obtained from BSgenome.Hsapiens.UCSC.hg38 reference genome. Only fragments with \nvalid 4-mer sequences (no N bases) were included.\n\n**Frequency Normalization**\n\n- Per-sample frequencies: count / total motifs\n- Z-score standardization for heatmap visualization (row-wise)\n\n### Motif Diversity Score (MDS)\n\nEnd motif diversity was quantified using Shannon entropy [@shannon1948entropy]:\n\n$$H = -\\sum_{i=1}^{256} p_i \\log_2(p_i)$$\n\nwhere $p_i$ is the frequency of motif $i$. The Motif Diversity Score (MDS) is normalized to [0,1]:\n\n$$MDS = \\frac{H}{\\log_2(256)}$$\n\nHigher MDS indicates more uniform motif usage; lower MDS suggests preferential cleavage at \nspecific sequences.\n\n### Dimensionality Reduction\n\n**PCA**: Principal component analysis on log10-transformed motif frequencies to visualize \nsample relationships in reduced dimensions.\n\n### Differential Motif Analysis\n\nTo identify motifs differentially abundant between ALS and Control:\n\n1. **Test**: Wilcoxon rank-sum test per motif\n2. **Effect size**: log2 fold-change (ALS/Ctrl)\n3. **Multiple testing**: Benjamini-Hochberg FDR correction\n4. **Significance threshold**: P < 0.05, |log2FC| > 0.05\n\n### Software\n\n- **Biostrings**: Sequence manipulation [@pages2024biostrings]\n- **ComplexHeatmap**: Hierarchical clustering visualization [@gu2016complexheatmap]\n- **ggplot2**: Statistical visualizations\n\n## Code\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"End Motif Extraction Code\"}\n# ============================================================================\n# END MOTIF ANALYSIS\n# ============================================================================\n\nmotifs_all <- function() {\n  bases <- c(\"A\", \"C\", \"G\", \"T\")\n  grid <- expand.grid(b1 = bases, b2 = bases, b3 = bases, b4 = bases, stringsAsFactors = FALSE)\n  apply(grid, 1, paste0, collapse = \"\")\n}\n\nshannon_entropy_bits <- function(p) {\n  p <- p[is.finite(p) & p > 0]\n  -sum(p * log2(p))\n}\n\nvalid_seqnames <- seqnames(genome)\nALL_4MERS <- motifs_all()\n\nextract_4mer_counts_from_frag_bed <- function(frag_bed_gz, sample_id, genome, valid_seqnames, motifs_all, chunk_size = 200000L) {\n  counts <- setNames(integer(length(motifs_all)), motifs_all)\n  con <- gzfile(frag_bed_gz, open = \"rt\")\n  on.exit(try(close(con), silent = TRUE), add = TRUE)\n  \n  total_extracted <- 0L\n  \n  repeat {\n    x <- tryCatch({\n      utils::read.delim(\n        file = con, header = FALSE, sep = \"\\t\", nrows = chunk_size,\n        col.names = FRAG_COLS, colClasses = FRAG_COL_CLASSES,\n        stringsAsFactors = FALSE, quote = \"\"\n      )\n    }, error = function(e) NULL)\n    \n    if (is.null(x) || nrow(x) == 0) break\n    \n    x <- x %>%\n      dplyr::filter(\n        chrom %in% valid_seqnames,\n        is.finite(start0), is.finite(end0),\n        start0 >= 0L, end0 > start0\n      )\n    if (nrow(x) == 0) next\n    \n    # Left end (+ strand)\n    gr_l <- GenomicRanges::GRanges(\n      seqnames = x$chrom,\n      ranges = IRanges::IRanges(start = x$start0 + 1L, width = 4L),\n      strand = \"+\"\n    )\n    \n    # Right end (- strand, reverse complement)\n    r_start0 <- x$end0 - 4L\n    keep_r <- is.finite(r_start0) & r_start0 >= 0L\n    gr_r <- GenomicRanges::GRanges(\n      seqnames = x$chrom[keep_r],\n      ranges = IRanges::IRanges(start = r_start0[keep_r] + 1L, width = 4L),\n      strand = \"-\"\n    )\n    \n    s_l <- Biostrings::getSeq(genome, gr_l)\n    s_r <- if (length(gr_r) > 0) Biostrings::getSeq(genome, gr_r) else Biostrings::DNAStringSet()\n    \n    motifs <- toupper(c(as.character(s_l), as.character(s_r)))\n    motifs <- motifs[nchar(motifs) == 4 & grepl(\"^[ACGT]{4}$\", motifs)]\n    \n    if (length(motifs) > 0) {\n      counts <- counts + as.integer(table(factor(motifs, levels = motifs_all)))\n      total_extracted <- total_extracted + length(motifs)\n    }\n    \n    rm(x)\n    gc(verbose = FALSE)\n  }\n  \n  message(sprintf(\"  %s: extracted %s motifs\", sample_id, format(total_extracted, big.mark = \",\")))\n  tibble::tibble(sample_id = sample_id, motif = names(counts), count = as.integer(counts))\n}\n\n# Extract motifs from all samples\nsample_frag_paths <- metadata %>%\n  dplyr::transmute(\n    sample_id = sample_id,\n    frag_bed = file.path(FRAG_DIR, paste0(sample_id, \".fragments.bed.gz\"))\n  )\n\nmotif_counts <- purrr::map2_dfr(\n  sample_frag_paths$sample_id,\n  sample_frag_paths$frag_bed,\n  ~extract_4mer_counts_from_frag_bed(.y, .x, genome = genome, valid_seqnames = valid_seqnames, motifs_all = ALL_4MERS)\n)\n\nmotif_long <- motif_counts %>%\n  dplyr::left_join(metadata, by = \"sample_id\") %>%\n  dplyr::group_by(sample_id) %>%\n  dplyr::mutate(\n    total = sum(count),\n    frequency = ifelse(total > 0, count / total, 0)\n  ) %>%\n  dplyr::ungroup()\n\nreadr::write_csv(motif_long, file.path(TABLE_DIR, \"end_motif_4mer_frequencies_long.csv\"))\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"End Motif Visualization Code\"}\n# ============================================================================\n# END MOTIF VISUALIZATION\n# ============================================================================\n\n# Load pre-computed motif data\nmotif_long <- readr::read_csv(file.path(TABLE_DIR, \"end_motif_4mer_frequencies_long.csv\"), show_col_types = FALSE)\n\nfreq_mat <- motif_long %>%\n  dplyr::select(motif, sample_id, frequency) %>%\n  tidyr::pivot_wider(names_from = sample_id, values_from = frequency, values_fill = 0) %>%\n  tibble::column_to_rownames(\"motif\") %>%\n  as.matrix()\n\nfreq_mat <- freq_mat[, match(metadata$sample_id, colnames(freq_mat))]\n\n# Top 20 motifs bar plot\nmotif_summary <- motif_long %>%\n  dplyr::group_by(Group, motif) %>%\n  dplyr::summarise(mean_freq = mean(frequency), sd_freq = sd(frequency), .groups = \"drop\")\n\ntop20 <- motif_summary %>%\n  dplyr::group_by(motif) %>%\n  dplyr::summarise(total_mean = sum(mean_freq), .groups = \"drop\") %>%\n  dplyr::arrange(desc(total_mean)) %>%\n  dplyr::slice_head(n = 20) %>%\n  dplyr::pull(motif)\n\np_top20 <- motif_summary %>%\n  dplyr::filter(motif %in% top20) %>%\n  dplyr::mutate(motif = factor(motif, levels = rev(top20))) %>%\n  ggplot(aes(x = motif, y = mean_freq, fill = Group)) +\n  geom_col(position = position_dodge(width = 0.75), width = 0.7) +\n  scale_fill_manual(values = COLORS) +\n  coord_flip() +\n  labs(title = \"Top 20 cfDNA 5' end motifs (4-mer)\",\n       subtitle = \"Mean motif frequency by group\",\n       x = NULL, y = \"Mean frequency\", fill = \"Group\") +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"top\")\n\n# Hierarchical clustering heatmap\nz_mat <- t(scale(t(freq_mat)))\nz_mat[!is.finite(z_mat)] <- 0\n\nanno_df <- metadata %>%\n  dplyr::distinct(sample_id, Group) %>%\n  dplyr::filter(sample_id %in% colnames(z_mat)) %>%\n  dplyr::arrange(match(sample_id, colnames(z_mat))) %>%\n  tibble::column_to_rownames(\"sample_id\")\n\nha <- ComplexHeatmap::HeatmapAnnotation(\n  df = anno_df,\n  col = list(Group = COLORS),\n  annotation_name_gp = grid::gpar(fontface = \"bold\", fontsize = 10)\n)\n\nht <- ComplexHeatmap::Heatmap(\n  z_mat,\n  name = \"Z-score\",\n  top_annotation = ha,\n  cluster_rows = TRUE,\n  cluster_columns = TRUE,\n  show_column_names = FALSE,\n  show_row_names = TRUE,\n  row_names_gp = grid::gpar(fontsize = 6),\n  column_title = \"Samples\",\n  row_title = \"5' 4-mer end motifs (n = 256)\",\n  col = circlize::colorRamp2(c(-2, 0, 2), c(\"#3B4CC0\", \"white\", \"#B40426\"))\n)\n\npng(file.path(FIG_DIR, \"fig5B_end_motif_4mer_clustering_heatmap.png\"),\n    width = 5000, height = 7000, res = 450)\nComplexHeatmap::draw(ht, heatmap_legend_side = \"right\", annotation_legend_side = \"right\")\ndev.off()\n\n# Motif Diversity Score (MDS)\nmds_tbl <- tibble::tibble(sample_id = colnames(freq_mat)) %>%\n  dplyr::mutate(\n    entropy_bits = apply(freq_mat, 2, shannon_entropy_bits),\n    mds = entropy_bits / log2(nrow(freq_mat))\n  ) %>%\n  dplyr::left_join(metadata, by = \"sample_id\")\n\nreadr::write_csv(mds_tbl, file.path(TABLE_DIR, \"end_motif_mds.csv\"))\n\np_mds <- ggplot(mds_tbl, aes(x = Group, y = mds, fill = Group)) +\n  geom_boxplot(width = 0.55, outlier.shape = NA, alpha = 0.85) +\n  geom_jitter(width = 0.12, size = 2.0, alpha = 0.75) +\n  scale_fill_manual(values = COLORS) +\n  labs(title = \"End-motif diversity (MDS)\",\n       subtitle = \"Shannon entropy of 256 4-mer frequencies (normalized by log2(256))\",\n       x = NULL, y = \"Motif diversity score (0–1)\") +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"none\")\n\n# PCA\nX <- t(freq_mat)\nX <- log10(X + 1e-6)\npca <- prcomp(X, center = TRUE, scale. = TRUE)\n\npca_df <- as.data.frame(pca$x[, 1:2, drop = FALSE]) %>%\n  tibble::rownames_to_column(\"sample_id\") %>%\n  dplyr::left_join(metadata, by = \"sample_id\")\n\nvar_expl <- (pca$sdev^2) / sum(pca$sdev^2)\npc1_lab <- sprintf(\"PC1 (%.1f%%)\", 100 * var_expl[1])\npc2_lab <- sprintf(\"PC2 (%.1f%%)\", 100 * var_expl[2])\n\np_pca <- ggplot(pca_df, aes(x = PC1, y = PC2, color = Group, label = sample_id)) +\n  geom_point(size = 3, alpha = 0.9) +\n  stat_ellipse(type = \"norm\", level = 0.68, linewidth = 0.6, alpha = 0.2) +\n  geom_text(size = 2.7, hjust = 0.5, vjust = -0.7, show.legend = FALSE, alpha = 0.88, check_overlap = TRUE) +\n  scale_color_manual(values = COLORS) +\n  labs(title = \"PCA of samples using 256 end-motif frequencies\",\n       x = pc1_lab, y = pc2_lab, color = \"Group\") +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"top\")\n\n# Differential motifs + volcano\neps <- 1e-6\ndiff_tbl <- motif_long %>%\n  dplyr::select(Group, motif, frequency) %>%\n  dplyr::group_by(motif) %>%\n  dplyr::summarise(\n    mean_Ctrl = mean(frequency[Group == \"Ctrl\"]),\n    mean_ALS = mean(frequency[Group == \"ALS\"]),\n    log2fc = log2((mean_ALS + eps) / (mean_Ctrl + eps)),\n    p = if (dplyr::n_distinct(Group) < 2) NA_real_ else wilcox.test(frequency ~ Group)$p.value,\n    .groups = \"drop\"\n  ) %>%\n  dplyr::mutate(\n    padj = p.adjust(p, method = \"BH\"),\n    neglog10_padj = -log10(padj),\n    neglog10_p = -log10(p)\n  )\n\nreadr::write_csv(diff_tbl, file.path(TABLE_DIR, \"end_motif_differential_motifs.csv\"))\n\nsig_cut <- 0.05\nlfc_cut <- 0.05\ndiff_tbl <- diff_tbl %>%\n  dplyr::mutate(\n    status = dplyr::case_when(\n      !is.na(p) & p < sig_cut & log2fc > lfc_cut ~ \"Higher in ALS\",\n      !is.na(p) & p < sig_cut & log2fc < -lfc_cut ~ \"Higher in Ctrl\",\n      TRUE ~ \"Not significant\"\n    ),\n    status = factor(status, levels = c(\"Higher in ALS\", \"Higher in Ctrl\", \"Not significant\"))\n  )\n\nlabel_tbl <- diff_tbl %>%\n  dplyr::filter(status != \"Not significant\") %>%\n  dplyr::arrange(p) %>%\n  dplyr::slice_head(n = 10)\n\np_volcano <- ggplot(diff_tbl, aes(x = log2fc, y = neglog10_p, color = status)) +\n  geom_hline(yintercept = -log10(sig_cut), linetype = \"dashed\", color = \"gray60\", linewidth = 0.4) +\n  geom_vline(xintercept = c(-lfc_cut, lfc_cut), linetype = \"dashed\", color = \"gray60\", linewidth = 0.4) +\n  geom_point(alpha = 0.85, size = 2.2) +\n  geom_text(data = label_tbl, aes(label = motif, color = status),\n            size = 3, vjust = -0.7, check_overlap = TRUE, show.legend = FALSE) +\n  scale_color_manual(values = c(\"Higher in ALS\" = unname(COLORS[\"ALS\"]),\n                                \"Higher in Ctrl\" = unname(COLORS[\"Ctrl\"]),\n                                \"Not significant\" = \"gray70\"), drop = FALSE) +\n  labs(title = \"Differential end motifs (ALS vs Ctrl)\",\n       subtitle = \"Wilcoxon test per motif\",\n       x = \"log2 fold-change (ALS / Ctrl)\", y = expression(-log[10](\"p-value\")), color = NULL) +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"top\")\n\n# Combined figure\nht_grob <- grid::grid.grabExpr(\n  ComplexHeatmap::draw(ht, heatmap_legend_side = \"right\", annotation_legend_side = \"right\")\n)\np_ht <- patchwork::wrap_elements(full = ht_grob)\n\np_end_motif_combined <- (p_top20 | p_ht) / (p_mds | p_pca | p_volcano) +\n  patchwork::plot_annotation(tag_levels = \"A\") +\n  patchwork::plot_layout(heights = c(2.5, 1.6))\n\nggsave(file.path(FIG_DIR, \"fig5_end_motif_analysis.png\"),\n       p_end_motif_combined, width = 18, height = 18, dpi = 300)\n```\n:::\n\n\n## Results\n\n### End Motif Profiling\n\n![End motif analysis. (A) Top 20 most frequent 5' end 4-mer motifs by group. (B) Hierarchical clustering heatmap of all 256 motifs (row Z-scores). (C) Motif diversity score comparison. (D) PCA of samples based on motif frequencies. (E) Volcano plot of differential motifs.](results/figures/fig5_end_motif_analysis.png){#fig-end-motif width=\"100%\"}\n\n### Key Findings\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n**Differential Motif Summary:**\n\n- Total motifs analyzed: 256\n- Significantly different (P < 0.05): 11\n- Higher in ALS: 8\n- Higher in Control: 3\n\n**Biological Interpretation:**\n\n- **Motif diversity** appears comparable between groups, suggesting global nuclease activity is preserved\n- **PCA** shows no clear separation between ALS and Control.\n\n:::\n\n---\n\n# DNA Methylation Analysis {#sec-dmr}\n\n::: {.panel-tabset}\n\n## Methods\n\n### Data Processing\n\nBisulfite-converted DNA methylation data was processed using the Bismark pipeline [@krueger2011bismark].\nCoverage files containing per-CpG methylation calls were loaded into R using the bsseq package \n[@hansen2012bsmooth].\n\n**BSseq Object Construction**\n\n- Input: Bismark coverage files (*.bismark.cov.gz)\n- Format: chromosome, position, end, methylation%, count_methylated, count_unmethylated\n- Strand collapsing: CpGs on opposite strands combined\n- Zero-coverage sites: Removed during import\n\n**Quality Filtering**\n\nCpG sites were retained if they had coverage in at least one sample per group (ALS and Control),\nensuring sufficient data for differential analysis while preserving low-coverage regions \ncharacteristic of cfDNA WGBS.\n\n### Differentially Methylated Region (DMR) Detection\n\nDMRs were identified using dmrseq [@korthauer2018dmrseq], specifically designed for low-coverage \nWGBS data:\n\n**BSmooth Smoothing**\n\nThe algorithm internally applies BSmooth smoothing [@hansen2012bsmooth] to borrow strength from \nneighboring CpGs:\n\n- Smoothing span: 1000 bp\n- Minimum CpGs in smoothing window: 15\n- Maximum gap for smoothing: 2500 bp\n\n**Candidate Region Detection**\n\n- Effect size cutoff: β > 0.05\n- Minimum CpGs per region: 3\n- Maximum gap within DMR: 1000 bp\n- Attempted to quantify methylation levels within skeletal muscle-specific marker regions identified by the WGBS human tissue atlas (Loyfer et al., 2023). However, due to limited sequencing coverage, was unable to recover sufficient data across those regions.\n\n**Statistical Inference**\n\n- Permutation-based null distribution for regional statistics\n- FDR control via empirical p-values\n- Significance threshold: p ≤ 0.05\n\n### Visualization\n\n**Methylation Distribution**\n\n- 1 kb genomic tiles computed across chr21\n- Mean methylation per tile per sample\n- Density plots comparing ALS vs Control\n\n**Dimensionality Reduction**\n\n- PCA on top 5000 most variable tiles (by MAD)\n- Data centered and scaled before PCA\n\n**Differential Methylation Plots**\n\n- Volcano: effect size (β) vs -log10(p-value)\n- Manhattan: genomic position vs -log10(p-value)\n\n### Software\n\n- **bsseq**: Bisulfite sequencing data analysis [@hansen2012bsmooth]\n- **dmrseq**: DMR detection for low-coverage WGBS [@korthauer2018dmrseq]\n- **BiocParallel**: Parallel computation\n- **ComplexHeatmap**: Heatmap visualization [@gu2016complexheatmap]\n\n## Code\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"DMR Analysis Data Processing\"}\n# ============================================================================\n# DNA METHYLATION ANALYSIS (dmrseq)\n# ============================================================================\n\n# dmrseq parameters\nCUTOFF         <- 0.05    # Effect size cutoff for candidate region detection\nMIN_NUM_REGION <- 3       # Minimum CpGs per candidate region\nSIG_THRESHOLD  <- 0.05    # Significance threshold for DMRs\n\n# Load Bismark coverage files\ncov_tbl <- tibble::tibble(\n  cov_file = list.files(\n    path = BISMARK_COV_DIR,\n    pattern = \"\\\\.bismark\\\\.cov\\\\.gz$\",\n    full.names = TRUE,\n    recursive = TRUE\n  )\n) %>%\n  dplyr::mutate(sample_id = sub(\"\\\\..*\", \"\", basename(cov_file)))\n\nmetadata_cov <- metadata %>%\n  dplyr::left_join(cov_tbl, by = \"sample_id\") %>%\n  dplyr::filter(!is.na(cov_file))\n\nmessage(sprintf(\"Found %d samples with Bismark coverage files.\", nrow(metadata_cov)))\n\n# Read Bismark coverage files into BSseq object\nbs <- bsseq::read.bismark(\n  files = metadata_cov$cov_file,\n  rmZeroCov = TRUE,\n  strandCollapse = TRUE,\n  verbose = TRUE\n)\n\npData(bs)$Group <- metadata_cov$Group\npData(bs)$sample_id <- metadata_cov$sample_id\n\nmessage(sprintf(\"BSseq object: %d CpG loci, %d samples\", nrow(bs), ncol(bs)))\n\nsaveRDS(bs, file.path(RDS_DIR, \"bsseq_object.rds\"))\n\n# Filter low-coverage CpGs\ncov_mat <- bsseq::getCoverage(bs, type = \"Cov\")\n\nctrl_idx <- which(metadata_cov$Group == \"Ctrl\")\nals_idx  <- which(metadata_cov$Group == \"ALS\")\n\nctrl_covered <- rowSums(cov_mat[, ctrl_idx] > 0) >= 1\nals_covered  <- rowSums(cov_mat[, als_idx] > 0) >= 1\n\nkeep_loci <- ctrl_covered & als_covered\nbs_filt <- bs[keep_loci, ]\n\nmessage(sprintf(\"After filtering: %d CpG loci (%.1f%% retained)\",\n                nrow(bs_filt), 100 * nrow(bs_filt) / nrow(bs)))\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"DMR Detection Code\"}\n# ============================================================================\n# DMR DETECTION\n# ============================================================================\n\n# Run dmrseq (or load cached results)\nif (file.exists(file.path(RDS_DIR, \"dmrseq_results_raw.rds\"))) {\n  dmrs <- readRDS(file.path(RDS_DIR, \"dmrseq_results_raw.rds\"))\n} else {\n  dmrs <- dmrseq::dmrseq(\n    bs = bs_filt,\n    testCovariate = \"Group\",\n    cutoff = CUTOFF,\n    minNumRegion = MIN_NUM_REGION,\n    bpSpan = 1000,\n    minInSpan = 15,\n    maxGapSmooth = 2500,\n    maxGap = 1000,\n    verbose = TRUE,\n    BPPARAM = BiocParallel::MulticoreParam(workers = 4)\n  )\n  saveRDS(dmrs, file.path(RDS_DIR, \"dmrseq_results_raw.rds\"))\n}\n\nmessage(sprintf(\"dmrseq found %d candidate regions.\", length(dmrs)))\n\n# Format DMR results\ndmr_df <- as.data.frame(dmrs) %>%\n  tibble::as_tibble() %>%\n  dplyr::rename(chr = seqnames) %>%\n  dplyr::mutate(\n    width = end - start + 1,\n    mid = as.integer(floor((start + end) / 2)),\n    direction = dplyr::case_when(\n      beta > 0 ~ \"Hyper (ALS>Ctrl)\",\n      beta < 0 ~ \"Hypo (ALS<Ctrl)\",\n      TRUE ~ \"None\"\n    ),\n    is_sig = !is.na(pval) & pval <= SIG_THRESHOLD\n  )\n\nreadr::write_csv(dmr_df, file.path(TABLE_DIR, \"dmrseq_results_all.csv\"))\n\n# Significant DMRs\ndmr_sig <- dmr_df %>%\n  dplyr::filter(is_sig) %>%\n  dplyr::arrange(pval)\n\ndmr_summary <- dmr_sig %>%\n  dplyr::count(direction, name = \"n_DMRs\") %>%\n  dplyr::mutate(total = sum(n_DMRs), pct = round(100 * n_DMRs / total, 1))\n\nreadr::write_csv(dmr_summary, file.path(TABLE_DIR, \"dmrseq_DMRs_summary.csv\"))\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"DMR Visualization Code\"}\n# ============================================================================\n# DMR VISUALIZATION\n# ============================================================================\n\n# Compute tiled methylation matrix\ntile_gr <- GenomicRanges::tileGenome(\n  seqlens <- GenomeInfoDb::seqlengths(genome)[paste0(\"chr\", c(21))],\n  tilewidth = 1000,\n  cut.last.tile.in.chrom = TRUE\n)\n\nmeth_by_tile <- bsseq::getMeth(bs_filt, regions = tile_gr, type = \"raw\", what = \"perRegion\")\ncolnames(meth_by_tile) <- metadata_cov$sample_id\nrownames(meth_by_tile) <- sprintf(\"%s_%d_%d\", as.character(GenomicRanges::seqnames(tile_gr)), \n                                  GenomicRanges::start(tile_gr), GenomicRanges::end(tile_gr))\n\nkeep_tiles <- rowSums(!is.na(meth_by_tile)) > 0\ntile_mat <- meth_by_tile[keep_tiles, ] * 100  # Convert to percent\n\nsaveRDS(tile_mat, file.path(RDS_DIR, \"dmrseq_tile_methylation_matrix.rds\"))\n\n# Methylation density plot\nmeth_long <- as.data.frame(tile_mat) %>%\n  tibble::rownames_to_column(\"tile_id\") %>%\n  tidyr::pivot_longer(-tile_id, names_to = \"sample_id\", values_to = \"pct_meth\") %>%\n  dplyr::left_join(metadata %>% dplyr::select(sample_id, Group), by = \"sample_id\") %>%\n  dplyr::filter(!is.na(pct_meth))\n\np_density <- ggplot(meth_long, aes(x = pct_meth, color = Group)) +\n  geom_density(linewidth = 0.9, alpha = 0.9) +\n  scale_color_manual(values = COLORS) +\n  labs(\n    title = \"cfDNA WGBS methylation distribution (1 kb tiles)\",\n    subtitle = \"Percent methylation across tiled windows (chr21)\",\n    x = \"Percent methylation (%)\", y = \"Density\", color = \"Group\"\n  ) +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"top\")\n\n# PCA on most variable tiles\nmat <- tile_mat\nkeep_rows <- rowSums(is.na(mat)) == 0\nmat <- mat[keep_rows, , drop = FALSE]\n\nif (nrow(mat) > 100) {\n  mad_v <- apply(mat, 1, stats::mad, na.rm = TRUE)\n  top_n <- min(5000L, nrow(mat))\n  top_idx <- order(mad_v, decreasing = TRUE)[seq_len(top_n)]\n  mat_top <- mat[top_idx, , drop = FALSE]\n  \n  pca <- prcomp(t(mat_top), center = TRUE, scale. = TRUE)\n  pca_df <- tibble::tibble(\n    sample_id = rownames(pca$x),\n    PC1 = pca$x[, 1],\n    PC2 = pca$x[, 2]\n  ) %>%\n    dplyr::left_join(metadata, by = \"sample_id\")\n  \n  var_expl <- (pca$sdev^2) / sum(pca$sdev^2)\n  \n  p_pca <- ggplot(pca_df, aes(x = PC1, y = PC2, color = Group)) +\n    geom_point(size = 3.5, alpha = 0.9) +\n    ggrepel::geom_text_repel(aes(label = sample_id), size = 2.8, max.overlaps = 20) +\n    scale_color_manual(values = COLORS) +\n    labs(\n      title = sprintf(\"PCA of %d most variable 1 kb tiles (chr21)\", top_n),\n      subtitle = sprintf(\"PC1 %.1f%%, PC2 %.1f%% variance explained\", 100 * var_expl[1], 100 * var_expl[2]),\n      x = sprintf(\"PC1 (%.1f%%)\", 100 * var_expl[1]),\n      y = sprintf(\"PC2 (%.1f%%)\", 100 * var_expl[2]),\n      color = \"Group\"\n    ) +\n    theme_pub(base_size = 12) +\n    theme(legend.position = \"top\")\n}\n\n# Heatmap of most variable tiles\nz_mat <- t(scale(t(mat_top)))\nz_mat[!is.finite(z_mat)] <- 0\n\nsample_order <- metadata %>%\n  dplyr::arrange(Group, sample_id) %>%\n  dplyr::pull(sample_id)\nsample_order <- intersect(sample_order, colnames(z_mat))\nz_mat <- z_mat[, sample_order, drop = FALSE]\n\nanno_df <- metadata %>%\n  dplyr::distinct(sample_id, Group) %>%\n  dplyr::filter(sample_id %in% colnames(z_mat)) %>%\n  dplyr::arrange(match(sample_id, colnames(z_mat))) %>%\n  tibble::column_to_rownames(\"sample_id\")\n\nha <- ComplexHeatmap::HeatmapAnnotation(\n  df = anno_df,\n  col = list(Group = COLORS),\n  annotation_name_gp = grid::gpar(fontface = \"bold\", fontsize = 10)\n)\n\nht <- ComplexHeatmap::Heatmap(\n  z_mat,\n  name = \"Z-score\",\n  top_annotation = ha,\n  cluster_rows = TRUE,\n  cluster_columns = TRUE,\n  show_row_names = FALSE,\n  show_column_names = TRUE,\n  column_names_gp = grid::gpar(fontsize = 8),\n  column_title = \"Samples\",\n  row_title = sprintf(\"Top %d variable tiles\", nrow(z_mat)),\n  col = circlize::colorRamp2(c(-2, 0, 2), c(\"#3B4CC0\", \"white\", \"#B40426\"))\n)\n\n# Volcano plot\np_volcano <- ggplot(dmr_df, aes(x = beta, y = -log10(pval))) +\n  geom_point(aes(color = is_sig), alpha = 0.6, size = 1.5) +\n  geom_vline(xintercept = c(-CUTOFF, CUTOFF), linetype = \"dashed\", color = \"gray45\", linewidth = 0.4) +\n  geom_hline(yintercept = -log10(SIG_THRESHOLD), linetype = \"dashed\", color = \"gray45\", linewidth = 0.4) +\n  scale_color_manual(values = c(\"TRUE\" = \"#E64B35\", \"FALSE\" = \"gray70\"),\n                     labels = c(\"TRUE\" = \"Significant\", \"FALSE\" = \"Not sig.\")) +\n  labs(\n    title = \"Differential methylation (ALS vs Ctrl) — dmrseq\",\n    subtitle = sprintf(\"Significant: p ≤ %.2f\", SIG_THRESHOLD),\n    x = \"Effect size (beta coefficient)\",\n    y = expression(-log[10](p-value)),\n    color = NULL\n  ) +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"top\")\n\n# Manhattan plot\ndmr_chr <- dmr_df %>%\n  dplyr::mutate(\n    sig_dir = dplyr::case_when(\n      is_sig & beta > 0 ~ \"Hyper\",\n      is_sig & beta < 0 ~ \"Hypo\",\n      TRUE ~ \"Not sig.\"\n    )\n  )\n\np_manhattan <- ggplot(dmr_chr, aes(x = mid / 1e6, y = -log10(pval))) +\n  geom_point(aes(color = sig_dir), alpha = 0.75, size = 1.3) +\n  geom_hline(yintercept = -log10(SIG_THRESHOLD), linetype = \"dashed\", color = \"gray45\", linewidth = 0.4) +\n  scale_color_manual(values = c(\"Hyper\" = \"#E64B35\", \"Hypo\" = \"#4DBBD5\", \"Not sig.\" = \"gray75\")) +\n  labs(\n    title = \"Differential methylation along chr21 — dmrseq\",\n    subtitle = sprintf(\"p ≤ %.2f threshold shown\", SIG_THRESHOLD),\n    x = \"Genomic position (Mb)\",\n    y = expression(-log[10](p-value)),\n    color = NULL\n  ) +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"top\")\n\n# Combined figure\nht_grob <- grid::grid.grabExpr(\n  ComplexHeatmap::draw(ht, heatmap_legend_side = \"right\", annotation_legend_side = \"right\")\n)\np_ht <- patchwork::wrap_elements(full = ht_grob)\n\np_dmrseq_combined <- p_density / (p_pca | p_ht) / (p_volcano | p_manhattan) +\n  patchwork::plot_layout(heights = c(1, 1.2, 1.2)) +\n  patchwork::plot_annotation(tag_levels = \"A\")\n\nggsave(file.path(FIG_DIR, \"fig6_dmrseq_combined.png\"),\n       p_dmrseq_combined, width = 17, height = 20, dpi = 300)\n```\n:::\n\n\n## Results\n\n### Methylation Overview\n\n![DNA methylation analysis with dmrseq. (A) Methylation distribution across 1 kb tiles. (B) PCA of most variable tiles. (C) Heatmap of top variable tiles. (D) Volcano plot of DMR effect sizes vs significance. (E) Manhattan plot showing DMR positions along chr21.](results/figures/fig6_dmrseq_combined.png){#fig-dmrseq width=\"100%\"}\n\n### DMR Summary\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n**DMR Detection Results:**\n\n- Total candidate regions tested: 17846\n- Significant DMRs (p ≤ 0.05): 823\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Distribution of significant DMRs by methylation direction</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Direction </th>\n   <th style=\"text-align:right;\"> N DMRs </th>\n   <th style=\"text-align:right;\"> Total </th>\n   <th style=\"text-align:right;\"> Percent </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Hyper (ALS&gt;Ctrl) </td>\n   <td style=\"text-align:right;\"> 448 </td>\n   <td style=\"text-align:right;\"> 823 </td>\n   <td style=\"text-align:right;\"> 54.4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Hypo (ALS&lt;Ctrl) </td>\n   <td style=\"text-align:right;\"> 375 </td>\n   <td style=\"text-align:right;\"> 823 </td>\n   <td style=\"text-align:right;\"> 45.6 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n### Key Findings\n\n**Methylation Patterns:**\n\n- Global methylation distributions are similar between ALS and Control groups\n- Low sequencing coverage limits power for detecting subtle methylation differences\n- Attempted to quantify methylation levels within skeletal muscle-specific marker regions identified by the WGBS human tissue atlas (Loyfer et al., 2023). However, due to limited sequencing coverage, was unable to recover sufficient data across those regions\n\n\n**dmrseq Performance:**\n\n- dmrseq is specifically designed for low-coverage WGBS data like cfDNA sequencing\n- BSmooth smoothing borrows information from neighboring CpGs to improve estimates\n- Permutation-based inference provides proper FDR control even with small sample sizes\n\n**Biological Relevance:**\n\n- Tissue-of-origin methylation signatures could inform disease pathophysiology\n- Functional annotation and enrichment analysis could be performed to further investigate the biological relevance of the DMRs\n\n:::\n\n---\n\n# Classification Analysis {#sec-class}\n\n::: {.panel-tabset}\n\n## Methods\n\n### Feature Sets\n\nThree feature sets were evaluated for ALS vs Control classification:\n\n1. **stackHMM Methylation**: Median methylation per chromatin state from the universal stackHMM model (vu et al., 2022. Genome Biology), which captures functional genomic context. Genome-wide maps of chromatin marks such as histone modifications and open chromatin sites provide valuable information for annotating the non-coding genome, including identifying regulatory elements.\n   \n2. **End Motifs**: Log10-transformed 4-mer end motif frequencies (256 features), reflecting \n   nuclease cleavage preferences\n   \n3. **Methylation Tiles**: 1 kb tile methylation values from WGBS, providing regional \n   methylation signatures\n\n### Data Preprocessing\n\n**Missingness Filtering**\n\n- Features with >20% missing values across samples were removed prior to imputation\n- This ensures features have sufficient coverage for reliable estimation\n\n**Imputation**\n\n- Remaining missing values imputed using median of non-missing values per feature\n\n**Variance Filtering**\n\n- Features ranked by variance across samples\n- Top 50% retained (minimum 10-100 features depending on feature set)\n\n**Scaling**\n\n- Features standardized (z-score: mean = 0, SD = 1)\n\n### Feature Selection: Boruta Algorithm\n\nThe Boruta algorithm [@kursa2010boruta] was applied for unbiased feature selection:\n\n1. Create \"shadow\" features by shuffling each original feature\n2. Train Random Forest on original + shadow features\n3. Features significantly better than best shadow are \"Confirmed\"\n4. Features not significantly worse are \"Tentative\"\n5. Maximum 100 iterations\n\n### Feature Importance Visualization\n\nFeature importance was assessed using Random Forest's Mean Decrease Gini (MDG) metric from the \nfinal trained model. MDG measures the total decrease in node impurity (Gini index) averaged \nover all trees when a feature is used for splitting. Higher MDG indicates greater importance \nfor classification.\n\n### EnhA3 Methylation Analysis\n\nEnhA3 (Active Enhancer 3) methylation levels from stackHMM chromatin state annotations were \nextracted and compared between ALS and Control groups using boxplots with individual data \npoints overlaid.\n\n### Classification Model: Random Forest\n\nRandom Forest classifiers [@breiman2001random] were trained with the following parameters:\n\n- Number of trees: 500 (default)\n- Variables tried at each split (mtry): tuned via inner CV\n- Importance: permutation-based (Gini importance)\n\n### Nested Cross-Validation\n\nTo prevent information leakage and provide unbiased performance estimates, nested \ncross-validation was implemented using the nestedcv package [@lewis2023nestedcv]:\n\n**Outer Loop (Performance Estimation)**\n\n- Leave-One-Out Cross-Validation (LOOCV)\n- Each sample held out once as test set\n- Provides n independent predictions\n\n**Inner Loop (Hyperparameter Tuning)**\n\n- 5-fold cross-validation\n- mtry values tested: 2, √(p), p/3\n- Best mtry selected by accuracy\n\n**Rationale**\n\nNested CV is essential for small sample sizes to:\n\n- Avoid optimistic bias from single train/test splits\n- Properly separate feature selection from model evaluation\n- Provide reliable confidence intervals for performance metrics\n\n### Performance Metrics\n\n- **AUC**: Area Under the ROC Curve (DeLong 95% CI)\n- **Sensitivity**: True Positive Rate (TP / (TP + FN))\n- **Specificity**: True Negative Rate (TN / (TN + FP))\n- **Precision**: Positive Predictive Value (TP / (TP + FP))\n- **F1 Score**: Harmonic mean of precision and sensitivity\n\n### Software\n\n- **nestedcv**: Nested cross-validation framework [@lewis2023nestedcv]\n- **Boruta**: Feature selection [@kursa2010boruta]\n- **randomForest**: Classification model [@liaw2002randomforest]\n- **pROC**: ROC curve analysis and AUC computation [@robin2011proc]\n- **caret**: Model training utilities [@kuhn2008caret]\n\n## Code\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Feature Engineering Code\"}\n# ============================================================================\n# CLASSIFICATION ANALYSIS\n# ============================================================================\n\n# Helper functions\nfilter_by_variance <- function(mat, top_pct = 0.5, min_features = 10) {\n  vars <- apply(mat, 2, var, na.rm = TRUE)\n  vars[is.na(vars)] <- 0\n  n_keep <- min(max(min_features, floor(ncol(mat) * top_pct)), sum(vars > 0))\n  mat[, order(vars, decreasing = TRUE)[seq_len(n_keep)], drop = FALSE]\n}\n\nimpute_median <- function(mat) {\n  apply(mat, 2, function(x) { x[is.na(x)] <- median(x, na.rm = TRUE); x })\n}\n\npreprocess <- function(mat, top_pct, min_feat, max_missing = 0.2) {\n  # 1) Remove features missing in > max_missing fraction of samples\n  miss_frac <- colMeans(is.na(mat))\n  keep <- miss_frac <= max_missing\n  if (!any(keep)) {\n    o <- order(miss_frac, decreasing = FALSE)\n    keep_idx <- o[seq_len(min(min_feat, length(o)))]\n    mat <- mat[, keep_idx, drop = FALSE]\n  } else {\n    mat <- mat[, keep, drop = FALSE]\n  }\n  # 2) Impute remaining missing values (median per feature)\n  mat <- impute_median(mat)\n  # 3) Filter by variance, then scale\n  mat <- filter_by_variance(mat, top_pct, min_feat)\n  mat <- scale(mat)\n  mat[is.nan(mat)] <- 0\n  mat\n}\n\n# Load data\nbs <- readRDS(file.path(RDS_DIR, \"bsseq_object.rds\"))\n\nstackhmm_df <- readr::read_tsv(file.path(PROCESSED_DIR, \"hg38_genome_100_segments.bed\"),\n                               col_names = c(\"chr\", \"start\", \"end\", \"state\"),\n                               col_types = \"ciic\", progress = FALSE) %>%\n  dplyr::filter(chr == \"chr21\")\n\nstackhmm_gr <- GenomicRanges::GRanges(\n  seqnames = stackhmm_df$chr,\n  ranges = IRanges::IRanges(start = stackhmm_df$start + 1L, end = stackhmm_df$end),\n  state = stackhmm_df$state\n)\nstates <- unique(stackhmm_df$state)\n\nmotif_long <- readr::read_csv(file.path(TABLE_DIR, \"end_motif_4mer_frequencies_long.csv\"), show_col_types = FALSE)\ntile_mat_raw <- readRDS(file.path(RDS_DIR, \"dmrseq_tile_methylation_matrix.rds\"))\n\n# 1. stackHMM methylation features\ncpg_gr <- GenomicRanges::granges(bs)\nmeth_mat <- bsseq::getMeth(bs, type = \"raw\", what = \"perBase\")\ncolnames(meth_mat) <- pData(bs)$sample_id\n\nstackhmm_meth <- matrix(NA_real_, nrow = ncol(bs), ncol = length(states),\n                        dimnames = list(colnames(meth_mat), states))\nfor (i in seq_along(states)) {\n  cpg_idx <- S4Vectors::queryHits(GenomicRanges::findOverlaps(cpg_gr, stackhmm_gr[stackhmm_gr$state == states[i]]))\n  if (length(cpg_idx) > 0) {\n    stackhmm_meth[, states[i]] <- apply(meth_mat[cpg_idx, , drop = FALSE], 2, median, na.rm = TRUE)\n  }\n}\n\n# 2. End motif features (log-transformed)\nmotif_wide <- motif_long %>%\n  dplyr::select(sample_id, motif, frequency) %>%\n  tidyr::pivot_wider(names_from = motif, values_from = frequency, values_fill = 0) %>%\n  tibble::column_to_rownames(\"sample_id\") %>%\n  as.matrix()\nmotif_log <- log10(motif_wide[metadata$sample_id, ] + 1e-8)\n\n# 3. Methylation tile features\ntile_mat <- t(tile_mat_raw)[metadata$sample_id, ]\nif (is.null(colnames(tile_mat))) colnames(tile_mat) <- paste0(\"tile_\", seq_len(ncol(tile_mat)))\n\n# Preprocess all feature sets\nstackhmm_scaled <- preprocess(stackhmm_meth[metadata$sample_id, ], 0.5, 10)\nmotif_scaled <- preprocess(motif_log, 0.5, 50)\ntile_scaled <- preprocess(tile_mat, 0.05, 100)\n\nmessage(sprintf(\"  stackHMM: %d features, Motif: %d features, MethTile: %d features\",\n                ncol(stackhmm_scaled), ncol(motif_scaled), ncol(tile_scaled)))\n\nfeature_sets <- list(stackHMM = stackhmm_scaled, Motif = motif_scaled, MethTile = tile_scaled)\ny <- setNames(as.factor(metadata$Group), metadata$sample_id)\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Model Training Code\"}\n# ============================================================================\n# MODEL TRAINING WITH NESTED CV\n# ============================================================================\n\nN_INNER_FOLDS <- 5\nall_results <- list()\n\nfor (feat_name in names(feature_sets)) {\n  message(sprintf(\"  Training %s...\", feat_name))\n  X <- feature_sets[[feat_name]]\n  \n  # Boruta feature selection\n  set.seed(389)  # Reproducibility for Boruta\n  boruta_result <- Boruta::Boruta(x = X, y = y, doTrace = 0, maxRuns = 100)\n  selected <- Boruta::getSelectedAttributes(boruta_result, withTentative = TRUE)\n  \n  # Fallback if too few features selected\n  if (length(selected) < 3) {\n    imp <- Boruta::attStats(boruta_result)\n    imp <- imp[rownames(imp) %in% colnames(X), , drop = FALSE]\n    selected <- rownames(imp)[order(imp$meanImp, decreasing = TRUE)[seq_len(min(10, nrow(imp)))]]\n  }\n  selected <- intersect(selected, colnames(X))\n  if (length(selected) == 0) selected <- colnames(X)\n  \n  X_sel <- X[, selected, drop = FALSE]\n  \n  # Nested CV with Random Forest\n  mtry_vals <- unique(c(2, floor(sqrt(ncol(X_sel))), floor(ncol(X_sel) / 3)))\n  mtry_vals <- mtry_vals[mtry_vals > 0 & mtry_vals <= ncol(X_sel)]\n  \n  fit <- nestedcv::nestcv.train(\n    y = y, x = X_sel, method = \"rf\",\n    outer_method = \"LOOCV\",\n    n_inner_folds = N_INNER_FOLDS,\n    tuneGrid = data.frame(mtry = mtry_vals),\n    importance = TRUE,\n    cv.cores = 1,\n    verbose = FALSE\n  )\n  \n  all_results[[feat_name]] <- list(\n    model = fit,\n    boruta = boruta_result,\n    selected_features = selected\n  )\n}\n\nsaveRDS(all_results, file.path(RDS_DIR, \"nested_cv_results.rds\"))\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Performance Evaluation Code\"}\n# ============================================================================\n# PERFORMANCE METRICS\n# ============================================================================\n\nextract_metrics <- function(result, feature_set) {\n  fit <- result$model\n  cm <- fit$summary$table\n  \n  TP <- if (\"ALS\" %in% rownames(cm) && \"ALS\" %in% colnames(cm)) cm[\"ALS\", \"ALS\"] else 0\n  TN <- if (\"Ctrl\" %in% rownames(cm) && \"Ctrl\" %in% colnames(cm)) cm[\"Ctrl\", \"Ctrl\"] else 0\n  FP <- if (\"ALS\" %in% rownames(cm) && \"Ctrl\" %in% colnames(cm)) cm[\"ALS\", \"Ctrl\"] else 0\n  FN <- if (\"Ctrl\" %in% rownames(cm) && \"ALS\" %in% colnames(cm)) cm[\"Ctrl\", \"ALS\"] else 0\n  \n  sens <- if ((TP + FN) > 0) TP / (TP + FN) else 0\n  spec <- if ((TN + FP) > 0) TN / (TN + FP) else 0\n  prec <- if ((TP + FP) > 0) TP / (TP + FP) else 0\n  f1 <- if ((prec + sens) > 0) 2 * prec * sens / (prec + sens) else 0\n  \n  auc_val <- auc_lower <- auc_upper <- NA\n  if (!is.null(fit$roc)) {\n    auc_val <- as.numeric(pROC::auc(fit$roc))\n    tryCatch({\n      ci <- pROC::ci.auc(fit$roc, method = \"delong\")\n      auc_lower <- ci[1]; auc_upper <- ci[3]\n    }, error = function(e) NULL)\n  }\n  \n  tibble::tibble(\n    feature_set = feature_set,\n    n_features = length(result$selected_features),\n    AUC = auc_val,\n    AUC_lower = auc_lower,\n    AUC_upper = auc_upper,\n    Sensitivity = sens,\n    Specificity = spec,\n    Precision = prec,\n    F1 = f1,\n    TP = TP, TN = TN, FP = FP, FN = FN\n  )\n}\n\nperformance_df <- purrr::map_dfr(names(all_results), ~extract_metrics(all_results[[.x]], .x)) %>%\n  dplyr::arrange(desc(AUC))\n\nreadr::write_csv(performance_df, file.path(TABLE_DIR, \"classification_performance_summary.csv\"))\n\nboruta_features_df <- purrr::map_dfr(names(all_results), ~tibble::tibble(\n  feature_set = .x,\n  feature = all_results[[.x]]$selected_features\n))\nreadr::write_csv(boruta_features_df, file.path(TABLE_DIR, \"boruta_selected_features.csv\"))\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Classification Visualization Code\"}\n# ============================================================================\n# CLASSIFICATION VISUALIZATIONS\n# ============================================================================\n\n# ROC Curves\nroc_data <- purrr::map_dfr(names(all_results), function(feat_name) {\n  roc_obj <- all_results[[feat_name]]$model$roc\n  if (is.null(roc_obj)) return(NULL)\n  \n  df <- data.frame(\n    fpr = 1 - roc_obj$specificities,\n    tpr = roc_obj$sensitivities,\n    feature_set = feat_name,\n    auc = as.numeric(pROC::auc(roc_obj))\n  )\n  df[order(df$fpr, df$tpr), ]\n})\n\nauc_lookup <- roc_data %>% dplyr::distinct(feature_set, auc)\nfeature_labels <- sapply(names(FEATURE_COLORS), function(fs) {\n  auc_val <- auc_lookup$auc[auc_lookup$feature_set == fs]\n  sprintf(\"%s (AUC=%.2f)\", fs, auc_val)\n})\n\np_roc <- ggplot(roc_data, aes(x = fpr, y = tpr, color = feature_set)) +\n  geom_path(linewidth = 1.2) +\n  geom_abline(intercept = 0, slope = 1, linetype = \"dashed\", color = \"gray50\") +\n  scale_color_manual(values = FEATURE_COLORS, labels = feature_labels) +\n  labs(\n    title = \"ROC Curves: ALS vs Control Classification\",\n    subtitle = \"Random Forest with Boruta feature selection (nested LOOCV)\",\n    x = \"False Positive Rate (1 - Specificity)\",\n    y = \"True Positive Rate (Sensitivity)\",\n    color = \"Feature Set\"\n  ) +\n  coord_equal(xlim = c(0, 1), ylim = c(0, 1)) +\n  theme_pub(base_size = 12) +\n  theme(legend.position = c(0.7, 0.25))\n\nggsave(file.path(FIG_DIR, \"fig7A_roc_curves_comparison.png\"), p_roc, width = 7, height = 6, dpi = 450)\n\n# Performance Barplot\nperf_long <- performance_df %>%\n  dplyr::select(feature_set, AUC, Sensitivity, Specificity, F1) %>%\n  tidyr::pivot_longer(-feature_set, names_to = \"metric\", values_to = \"value\") %>%\n  dplyr::mutate(metric = factor(metric, levels = c(\"AUC\", \"Sensitivity\", \"Specificity\", \"F1\")))\n\np_perf <- ggplot(perf_long, aes(x = feature_set, y = value, fill = feature_set)) +\n  geom_col(alpha = 0.9, width = 0.7) +\n  geom_text(aes(label = sprintf(\"%.2f\", value)), vjust = -0.3, size = 3.5) +\n  facet_wrap(~metric, nrow = 1) +\n  scale_fill_manual(values = FEATURE_COLORS) +\n  scale_y_continuous(limits = c(0, 1.1), breaks = seq(0, 1, 0.2)) +\n  labs(title = \"Classification Performance by Feature Set\", x = NULL, y = \"Score\") +\n  theme_pub(base_size = 11) +\n  theme(legend.position = \"none\", axis.text.x = element_text(angle = 45, hjust = 1))\n\nggsave(file.path(FIG_DIR, \"fig7B_performance_barplot.png\"), p_perf, width = 10, height = 5, dpi = 450)\n\n# Feature Importance - RF MeanDecreaseGini for all feature sets\nimp_plots <- list()\nfor (feat_name in names(all_results)) {\n  fit <- all_results[[feat_name]]$model\n  rf_imp <- fit$final_fit$finalModel$importance\n  imp_df <- data.frame(\n    feature = rownames(rf_imp),\n    importance = rf_imp[, \"MeanDecreaseGini\"]\n  ) %>% dplyr::arrange(desc(importance))\n  \n  top_n <- min(15, nrow(imp_df))\n  imp_df_top <- imp_df[seq_len(top_n), ]\n  \n  imp_plots[[feat_name]] <- ggplot(imp_df_top, \n    aes(x = reorder(feature, importance), y = importance)) +\n    geom_col(fill = FEATURE_COLORS[feat_name], alpha = 0.85) +\n    coord_flip() +\n    labs(title = feat_name, x = NULL, y = \"MeanDecreaseGini\") +\n    theme_pub(base_size = 9) +\n    theme(axis.text.y = element_text(size = 7))\n}\n\np_imp_combined <- patchwork::wrap_plots(imp_plots, nrow = 1) +\n  patchwork::plot_annotation(\n    title = \"Random Forest Feature Importance (MeanDecreaseGini)\",\n    theme = theme(plot.title = element_text(face = \"bold\", hjust = 0.5, size = 14))\n  )\n\nggsave(file.path(FIG_DIR, \"fig7C_rf_importance_combined.png\"), p_imp_combined, width = 14, height = 5, dpi = 450)\n\n# stackHMM Heatmap\nsample_order <- metadata %>% dplyr::arrange(Group) %>% dplyr::pull(sample_id)\nanno_df <- data.frame(Group = metadata$Group[match(sample_order, metadata$sample_id)],\n                      row.names = sample_order)\n\nha <- ComplexHeatmap::HeatmapAnnotation(\n  df = anno_df,\n  col = list(Group = COLORS),\n  annotation_name_gp = grid::gpar(fontface = \"bold\", fontsize = 10)\n)\n\nht <- ComplexHeatmap::Heatmap(\n  t(stackhmm_scaled[sample_order, ]),\n  name = \"Z-score\",\n  top_annotation = ha,\n  cluster_rows = TRUE,\n  cluster_columns = FALSE,\n  show_row_names = TRUE,\n  show_column_names = TRUE,\n  row_names_gp = grid::gpar(fontsize = 6),\n  column_names_gp = grid::gpar(fontsize = 8),\n  column_title = \"Samples\",\n  row_title = sprintf(\"stackHMM States (n=%d)\", ncol(stackhmm_scaled)),\n  col = circlize::colorRamp2(c(-2, 0, 2), c(\"#3B4CC0\", \"white\", \"#B40426\"))\n)\n\npng(file.path(FIG_DIR, \"fig7D_stackhmm_methylation_heatmap.png\"),\n    width = 10, height = 10, units = \"in\", res = 450)\nComplexHeatmap::draw(ht)\ndev.off()\n\n# EnhA3 Methylation Boxplot\nplot_matrix <- stackhmm_meth %>%\n  as.data.frame() %>%\n  tibble::rownames_to_column(\"sample_id\") %>%\n  dplyr::left_join(metadata, by = \"sample_id\")\n\np_enha3 <- ggplot(plot_matrix, aes(x = Group, y = `45_EnhA3`, fill = Group)) +\n  geom_boxplot(alpha = 0.8, outlier.shape = NA) +\n  geom_jitter(shape = 16, size = 2, alpha = 0.8, width = 0.15) +\n  scale_fill_manual(values = COLORS) +\n  labs(x = NULL, y = \"EnhA3 methylation level\",\n       title = \"EnhA3 (Active Enhancer 3) Methylation\") +\n  theme_pub(base_size = 12) +\n  theme(legend.position = \"none\")\n\nggsave(file.path(FIG_DIR, \"fig7E_enha3_methylation_boxplot.png\"), p_enha3, width = 5, height = 5, dpi = 450)\n\n# Combined Classification Figure\np_ht <- patchwork::wrap_elements(full = grid::grid.grabExpr(\n  ComplexHeatmap::draw(ht, heatmap_legend_side = \"right\", annotation_legend_side = \"right\")\n))\n\np_classification_combined <- p_perf / p_imp_combined / (p_roc | p_ht | p_enha3) +\n  patchwork::plot_layout(heights = c(1, 1, 1.2)) +\n  patchwork::plot_annotation(tag_levels = \"A\")\n\nggsave(file.path(FIG_DIR, \"fig7_classification_analysis_combined.png\"),\n       p_classification_combined, width = 18, height = 16, dpi = 300)\n```\n:::\n\n\n## Results\n\n### Classification Performance\n\n![Classification analysis. (A) ROC curves comparing three feature sets for ALS vs Control discrimination. (B) Performance metrics (AUC, Sensitivity, Specificity, F1) by feature set. (C) Top features by Boruta importance for the best-performing model. (D) Heatmap of stackHMM methylation features.](results/figures/fig7A_roc_curves_comparison.png){#fig-roc width=\"80%\"}\n\n### Performance Summary\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Classification performance summary (nested LOOCV)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Feature Set </th>\n   <th style=\"text-align:right;\"> N Features </th>\n   <th style=\"text-align:right;\"> AUC (95% CI) </th>\n   <th style=\"text-align:right;\"> Sensitivity </th>\n   <th style=\"text-align:right;\"> Specificity </th>\n   <th style=\"text-align:right;\"> F1 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Motif </td>\n   <td style=\"text-align:right;\"> 6 </td>\n   <td style=\"text-align:right;\"> 0.92 (0.80-1.00) </td>\n   <td style=\"text-align:right;\"> 0.83 </td>\n   <td style=\"text-align:right;\"> 0.80 </td>\n   <td style=\"text-align:right;\"> 0.83 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MethTile </td>\n   <td style=\"text-align:right;\"> 7 </td>\n   <td style=\"text-align:right;\"> 0.90 (0.77-1.00) </td>\n   <td style=\"text-align:right;\"> 0.92 </td>\n   <td style=\"text-align:right;\"> 0.80 </td>\n   <td style=\"text-align:right;\"> 0.88 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> stackHMM </td>\n   <td style=\"text-align:right;\"> 9 </td>\n   <td style=\"text-align:right;\"> 0.53 (0.26-0.80) </td>\n   <td style=\"text-align:right;\"> 0.75 </td>\n   <td style=\"text-align:right;\"> 0.50 </td>\n   <td style=\"text-align:right;\"> 0.69 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n![Performance comparison across feature sets.](results/figures/fig7B_performance_barplot.png){#fig-perf-bar width=\"90%\"}\n\n### Feature Importance\n\n![Random Forest feature importance (MeanDecreaseGini) for all three feature sets.](results/figures/fig7C_rf_importance_combined.png){#fig-importance width=\"100%\"}\n\n### EnhA3 Methylation\n\n![EnhA3 (Active Enhancer 3) methylation levels from stackHMM annotations compared between ALS and Control groups.](results/figures/fig7E_enha3_methylation_boxplot.png){#fig-enha3 width=\"50%\"}\n\n### Combined Classification Analysis\n\n![Combined classification analysis figure showing (A) Performance metrics, (B) Feature importance, (C) ROC curves, (D) stackHMM heatmap, and (E) EnhA3 methylation boxplot.](results/figures/fig7_classification_analysis_combined.png){#fig-class-combined width=\"100%\"}\n\n### Key Findings\n\n**Model Performance:**\n\n- Due to the small sample size and limited sequencing coverage, the classification performance needs to be interpreted with caution.\n- stackHMM-based features are meant to capture biologically meaningful chromatin state information\n- End motif features provide complementary information about nuclease preferences\n- Methylation tiles offer direct measurement of regional methylation differences\n\n**Methodological Considerations:**\n\n- **Nested CV** prevents overfitting and provides unbiased performance estimates\n- **Boruta feature selection** identifies robust predictors without arbitrary thresholds\n- Small sample size limits generalizability; larger cohorts needed for validation\n\n**Translational Potential:**\n\n- Multi-feature integration may improve sensitivity and specificity\n- Prospective validation in independent cohorts is essential\n\n:::\n\n---\n\n# Conclusions\n\nThis comprehensive analysis of cfDNA from WGBS data demonstrates the potential of cell-free DNA \nfragmentomics and methylation profiling for ALS detection. Key findings include:\n\n1. **Quality metrics** confirm high-quality bisulfite sequencing with >99% conversion efficiency\n2. **Fragment patterns** show characteristic nucleosome protection signals\n3. **End motifs** reveal little differences in nuclease cleavage preferences between ALS and Control\n4. **Methylation analysis** identifies candidate DMRs using methods appropriate for low-coverage data\n5. **Classification** achieves discrimination using multiple cfDNA features, but due to the small sample size and limited sequencing coverage, the classification performance needs to be interpreted with caution.\n\nFuture directions include expand the analyses to whole genome with deeper sequencing coverage, more in depth biological interpretation, validation in larger cohorts, integration with clinical variables, and \ninvestigation of tissue-of-origin contributions to the cfDNA methylation signature.\n\n---\n\n# Session Information\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.5.1 (2025-06-13)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sequoia 15.5\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n\nlocale:\n[1] en_US/en_US/en_US/C/en_US/en_US\n\ntime zone: America/Los_Angeles\ntzcode source: internal\n\nattached base packages:\n [1] grid      stats4    parallel  stats     graphics  grDevices utils    \n [8] datasets  methods   base     \n\nother attached packages:\n [1] annotatr_1.36.0                         \n [2] BiocParallel_1.44.0                     \n [3] dmrseq_1.30.0                           \n [4] bsseq_1.46.0                            \n [5] SummarizedExperiment_1.40.0             \n [6] MatrixGenerics_1.22.0                   \n [7] matrixStats_1.5.0                       \n [8] ComplexHeatmap_2.26.0                   \n [9] TxDb.Hsapiens.UCSC.hg38.knownGene_3.22.0\n[10] GenomicFeatures_1.62.0                  \n[11] BSgenome.Hsapiens.UCSC.hg38_1.4.5       \n[12] BSgenome_1.78.0                         \n[13] rtracklayer_1.70.1                      \n[14] BiocIO_1.20.0                           \n[15] GenomeInfoDb_1.46.2                     \n[16] org.Hs.eg.db_3.22.0                     \n[17] AnnotationDbi_1.72.0                    \n[18] Biobase_2.70.0                          \n[19] biomaRt_2.66.0                          \n[20] ChIPseeker_1.46.1                       \n[21] cigarillo_1.0.0                         \n[22] Rsamtools_2.26.0                        \n[23] Biostrings_2.78.0                       \n[24] XVector_0.50.0                          \n[25] GenomicRanges_1.62.1                    \n[26] IRanges_2.44.0                          \n[27] S4Vectors_0.48.0                        \n[28] Seqinfo_1.0.0                           \n[29] BiocGenerics_0.56.0                     \n[30] generics_0.1.4                          \n[31] kableExtra_1.4.0                        \n[32] knitr_1.51                              \n[33] Boruta_9.0.0                            \n[34] nestedcv_0.8.0                          \n[35] randomForest_4.7-1.2                    \n[36] circlize_0.4.17                         \n[37] ggpubr_0.6.2                            \n[38] here_1.0.2                              \n[39] patchwork_1.3.2                         \n[40] pROC_1.19.0.1                           \n[41] caret_7.0-1                             \n[42] lattice_0.22-7                          \n[43] tibble_3.3.1                            \n[44] stringr_1.6.0                           \n[45] purrr_1.2.1                             \n[46] readr_2.1.6                             \n[47] tidyr_1.3.2                             \n[48] dplyr_1.1.4                             \n[49] ggplot2_4.0.1                           \n\nloaded via a namespace (and not attached):\n  [1] R.methodsS3_1.8.2                       \n  [2] dichromat_2.0-0.1                       \n  [3] vroom_1.7.0                             \n  [4] progress_1.2.3                          \n  [5] nnet_7.3-20                             \n  [6] HDF5Array_1.38.0                        \n  [7] vctrs_0.7.1                             \n  [8] ggtangle_0.1.1                          \n  [9] digest_0.6.39                           \n [10] png_0.1-8                               \n [11] shape_1.4.6.1                           \n [12] ggrepel_0.9.6                           \n [13] parallelly_1.46.1                       \n [14] permute_0.9-8                           \n [15] MASS_7.3-65                             \n [16] fontLiberation_0.1.0                    \n [17] reshape2_1.4.5                          \n [18] bumphunter_1.52.0                       \n [19] foreach_1.5.2                           \n [20] qvalue_2.42.0                           \n [21] withr_3.0.2                             \n [22] xfun_0.56                               \n [23] ggfun_0.2.0                             \n [24] doRNG_1.8.6.2                           \n [25] survival_3.8-6                          \n [26] memoise_2.0.1                           \n [27] systemfonts_1.3.1                       \n [28] tidytree_0.4.7                          \n [29] GlobalOptions_0.1.3                     \n [30] gtools_3.9.5                            \n [31] R.oo_1.27.1                             \n [32] Formula_1.2-5                           \n [33] prettyunits_1.2.0                       \n [34] KEGGREST_1.50.0                         \n [35] otel_0.2.0                              \n [36] httr_1.4.7                              \n [37] rstatix_0.7.3                           \n [38] restfulr_0.0.16                         \n [39] globals_0.18.0                          \n [40] rhdf5filters_1.22.0                     \n [41] rhdf5_2.54.1                            \n [42] rstudioapi_0.18.0                       \n [43] UCSC.utils_1.6.1                        \n [44] DOSE_4.4.0                              \n [45] curl_7.0.0                              \n [46] h5mread_1.2.1                           \n [47] polyclip_1.10-7                         \n [48] SparseArray_1.10.8                      \n [49] doParallel_1.0.17                       \n [50] evaluate_1.0.5                          \n [51] S4Arrays_1.10.1                         \n [52] Rfast_2.1.5.2                           \n [53] BiocFileCache_3.0.0                     \n [54] hms_1.1.4                               \n [55] glmnet_4.1-10                           \n [56] colorspace_2.1-2                        \n [57] filelock_1.0.3                          \n [58] matrixTests_0.2.3.1                     \n [59] magrittr_2.0.4                          \n [60] ggtree_4.0.4                            \n [61] future.apply_1.20.1                     \n [62] XML_3.99-0.20                           \n [63] cowplot_1.2.0                           \n [64] class_7.3-23                            \n [65] pillar_1.11.1                           \n [66] nlme_3.1-168                            \n [67] iterators_1.0.14                        \n [68] caTools_1.18.3                          \n [69] compiler_4.5.1                          \n [70] beachmat_2.26.0                         \n [71] stringi_1.8.7                           \n [72] gower_1.0.2                             \n [73] lubridate_1.9.4                         \n [74] GenomicAlignments_1.46.0                \n [75] plyr_1.8.9                              \n [76] crayon_1.5.3                            \n [77] abind_1.4-8                             \n [78] gridGraphics_0.5-1                      \n [79] locfit_1.5-9.12                         \n [80] bit_4.6.0                               \n [81] fastmatch_1.1-8                         \n [82] codetools_0.2-20                        \n [83] textshaping_1.0.4                       \n [84] recipes_1.3.1                           \n [85] TxDb.Hsapiens.UCSC.hg19.knownGene_3.22.1\n [86] GetoptLong_1.1.0                        \n [87] splines_4.5.1                           \n [88] Rcpp_1.1.1                              \n [89] tidydr_0.0.6                            \n [90] dbplyr_2.5.1                            \n [91] sparseMatrixStats_1.22.0                \n [92] blob_1.3.0                              \n [93] clue_0.3-66                             \n [94] BiocVersion_3.22.0                      \n [95] fs_1.6.6                                \n [96] listenv_0.10.0                          \n [97] DelayedMatrixStats_1.32.0               \n [98] ggsignif_0.6.4                          \n [99] ggplotify_0.1.3                         \n[100] Matrix_1.7-4                            \n[101] statmod_1.5.1                           \n[102] tzdb_0.5.0                              \n[103] svglite_2.2.2                           \n[104] tweenr_2.0.3                            \n[105] pkgconfig_2.0.3                         \n[106] tools_4.5.1                             \n[107] cachem_1.1.0                            \n[108] RSQLite_2.4.5                           \n[109] viridisLite_0.4.2                       \n[110] DBI_1.2.3                               \n[111] zigg_0.0.2                              \n[112] fastmap_1.2.0                           \n[113] rmarkdown_2.30                          \n[114] scales_1.4.0                            \n[115] outliers_0.15                           \n[116] broom_1.0.12                            \n[117] AnnotationHub_4.0.0                     \n[118] BiocManager_1.30.27                     \n[119] carData_3.0-5                           \n[120] rpart_4.1.24                            \n[121] farver_2.1.2                            \n[122] scatterpie_0.2.6                        \n[123] yaml_2.3.12                             \n[124] cli_3.6.5                               \n[125] lifecycle_1.0.5                         \n[126] lava_1.8.2                              \n[127] backports_1.5.0                         \n[128] timechange_0.3.0                        \n[129] gtable_0.3.6                            \n[130] rjson_0.2.23                            \n[131] ape_5.8-1                               \n[132] limma_3.66.0                            \n[133] jsonlite_2.0.0                          \n[134] bitops_1.0-9                            \n[135] bit64_4.6.0-1                           \n[136] yulab.utils_0.2.3                       \n[137] RcppParallel_5.1.11-1                   \n[138] GOSemSim_2.36.0                         \n[139] R.utils_2.13.0                          \n[140] timeDate_4051.111                       \n[141] lazyeval_0.2.2                          \n[142] htmltools_0.5.9                         \n[143] enrichplot_1.30.4                       \n[144] GO.db_3.22.0                            \n[145] rappdirs_0.3.4                          \n[146] glue_1.8.0                              \n[147] httr2_1.2.2                             \n[148] gdtools_0.4.4                           \n[149] RCurl_1.98-1.17                         \n[150] rprojroot_2.1.1                         \n[151] treeio_1.34.0                           \n[152] boot_1.3-32                             \n[153] igraph_2.2.1                            \n[154] R6_2.6.1                                \n[155] ggiraph_0.9.3                           \n[156] gplots_3.3.0                            \n[157] rngtools_1.5.2                          \n[158] cluster_2.1.8.1                         \n[159] Rhdf5lib_1.32.0                         \n[160] regioneR_1.42.0                         \n[161] aplot_0.2.9                             \n[162] ipred_0.9-15                            \n[163] DelayedArray_0.36.0                     \n[164] tidyselect_1.2.1                        \n[165] plotrix_3.8-13                          \n[166] ggforce_0.5.0                           \n[167] xml2_1.5.2                              \n[168] fontBitstreamVera_0.1.1                 \n[169] car_3.1-3                               \n[170] future_1.69.0                           \n[171] ModelMetrics_1.2.2.2                    \n[172] KernSmooth_2.23-26                      \n[173] S7_0.2.1                                \n[174] fontquiver_0.2.1                        \n[175] data.table_1.18.2.1                     \n[176] htmlwidgets_1.6.4                       \n[177] fgsea_1.36.2                            \n[178] RColorBrewer_1.1-3                      \n[179] rlang_1.1.7                             \n[180] ggnewscale_0.5.2                        \n[181] hardhat_1.4.2                           \n[182] prodlim_2025.04.28                      \n```\n\n\n:::\n:::\n\n\n---\n\n# References\n\n::: {#refs}\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}